<!DOCTYPE html>
<html>
<head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>

    <style>
        /* --- LAYOUT RESET --- */
        * { box-sizing: border-box; }

        body {
            margin: 0;
            height: 100vh; 
            font-family: Arial, sans-serif;
            background-color: black;
            color: white;
            overflow: hidden; 
            display: flex;
            flex-direction: column; 
        }

        /* --- 1. THE FIXED HEADER --- */
        #sticky-header-group {
            flex: 0 0 auto; 
            background: #000;
            border-bottom: 1px solid #222;
            padding: 10px 20px;
            z-index: 50;
            position: relative; 
            display: flex;
            justify-content: center; 
            align-items: center;
            min-height: 100px; 
        }

        /* Number/Arrow in Top Right */
        #display {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%); 
            font-size: 80px; 
            font-weight: bold;
            user-select: none;
            line-height: 1;
            white-space: nowrap; 
            text-align: right;
            z-index: 20;
            text-shadow: 0 0 5px black;
        }

        /* --- CENTER CONTENT SWITCHER --- */
        #slideLabel {
            background: transparent;
            border-bottom: 1px solid #333; 
            color: #ddd;
            font-size: 30px; 
            outline: none;
            padding-bottom: 2px;
            min-width: 200px;
            max-width: 60%; 
            text-align: center; 
            transition: border-color 0.2s;
            cursor: text;
            display: block; 
        }
        #slideLabel:focus { border-bottom: 1px solid #fff; }

        /* --- PDF & DRAWING CONTAINER --- */
        #pdf-render-container {
            display: none; 
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 30vh; 
            position: relative; 
            transition: height 0.1s ease; 
        }

        /* Layer 1: The PDF */
        #the-canvas {
            max-height: 100%; 
            max-width: 80%;
            border: 1px solid #333;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            position: absolute; 
            z-index: 1;
        }

        /* Layer 2: The Drawing Layer */
        #draw-canvas {
            max-height: 100%; 
            max-width: 80%;
            position: absolute; 
            z-index: 2; 
            touch-action: none; 
            pointer-events: none; 
        }
        
        #draw-canvas.active {
            pointer-events: auto; 
            border: 1px dashed rgba(255, 255, 255, 0.2); 
        }

        #no-pdf-msg {
            color: #444;
            font-style: italic;
            position: absolute;
            font-size: 14px;
            z-index: 0;
        }

        /* --- 2. THE SCROLLING NOTES AREA --- */
        #notes-container {
            flex: 1; 
            position: relative;
            overflow: hidden; 
            display: flex;
            justify-content: center; 
            border-top: 1px solid #111;
        }

        #slideNotes {
            background: transparent;
            border: none;
            color: #aaa; 
            font-size: 18px; 
            text-align: left; 
            outline: none;
            font-family: 'Consolas', 'Courier New', monospace; 
            height: 100%; 
            width: 100%;
            max-width: 800px; 
            padding: 20px;
            overflow-y: auto; 
            white-space: pre-wrap; 
            line-height: 1.6;
        }
        
        #slideNotes::-webkit-scrollbar { width: 10px; }
        #slideNotes::-webkit-scrollbar-track { background: #111; }
        #slideNotes::-webkit-scrollbar-thumb { background: #333; border-radius: 5px; }

        /* --- SETTINGS MENU --- */
        #menu-container { position: absolute; top: 10px; left: 10px; z-index: 100; }
        
        #gear-btn {
            background: transparent;
            color: #555;
            border: none;
            font-size: 24px;
            cursor: pointer;
            padding: 5px;
            transition: color 0.2s;
        }
        #gear-btn:hover { color: #fff; }

        #controls-panel {
            display: none;
            margin-top: 5px;
            background: #111;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #333;
            flex-direction: column;
            gap: 15px;
            width: 280px; 
        }
        #controls-panel.active { display: flex; }

        button.action-btn {
            padding: 8px;
            font-size: 12px;
            cursor: pointer;
            background: #000;
            color: #ddd;
            border: 1px solid #444;
            border-radius: 4px;
        }
        button.action-btn:hover { background: #222; }
        
        .toolbar {
            display: flex;
            gap: 5px;
            background: #222;
            padding: 5px;
            border-radius: 5px;
        }
        
        .tool-btn {
            flex: 1;
            padding: 5px;
            font-size: 11px;
            cursor: pointer;
            background: #111;
            color: #888;
            border: 1px solid #444;
            border-radius: 3px;
        }
        
        .tool-btn.active {
            background: #444;
            color: #fff;
            border-color: #666;
            font-weight: bold;
        }

        #export-btn { border-color: #4CAF50; color: #4CAF50; }
        #export-btn:hover { background: #1b331c; }

        .control-group { display: flex; flex-direction: column; gap: 5px; }
        label { font-size: 12px; color: #888; }
        input[type=range] { width: 100%; cursor: pointer; accent-color: #888; }
        input[type=file] { font-size: 12px; color: #aaa; }
        
        #mode-status { color: #aaa; font-size: 12px; font-weight: bold; }
        #clear-data-btn { color: #ff4444; border-color: #552222; }

    </style>
</head>
<body>

    <div id="menu-container">
        <button id="gear-btn" onclick="toggleMenu()">⚙</button>
        <div id="controls-panel">
            
            <div class="control-group">
                <div id="mode-status">Mode: Standard</div>
                <button class="action-btn" onclick="cycleMode()">Switch Mode</button>
            </div>
            
            <div class="control-group" id="drawing-controls" style="display:none;">
                <label>Drawing Tools</label>
                <div class="toolbar">
                    <button class="tool-btn active" id="btn-pen" onclick="setTool('pen')">Pen</button>
                    <button class="tool-btn" id="btn-eraser" onclick="setTool('eraser')">Stroke Eraser</button>
                    <button class="tool-btn" style="color:#ff6666;" onclick="clearSlideDrawing()">Clear Slide</button>
                </div>
            </div>
            
            <hr style="width:100%; border:0; border-top:1px solid #333;">

            <div class="control-group">
                <label style="color:cyan;">1. Load Slides (PDF)</label>
                <input type="file" id="pdf-upload" accept=".pdf">
            </div>

            <div class="control-group">
                <label style="color:orange;">2. Import Notes (JSON)</label>
                <input type="file" id="json-upload" accept=".json">
            </div>

            <div class="control-group">
                <button id="export-btn" class="action-btn" onclick="exportNotes()">3. Save/Export Notes</button>
            </div>

            <hr style="width:100%; border:0; border-top:1px solid #333;">

            <div class="control-group">
                <label>Number Size</label>
                <input type="range" min="20" max="120" value="80" oninput="updateNumberSize(this.value)">
            </div>
            <div class="control-group">
                <label>Text Size</label>
                <input type="range" min="12" max="60" value="18" oninput="updateTextSize(this.value)">
            </div>
            <div class="control-group">
                <label>PDF Preview Size</label>
                <input type="range" min="10" max="60" value="30" oninput="updatePdfSize(this.value)" onchange="refreshPdfResolution()">
            </div>
            <button id="clear-data-btn" class="action-btn" onclick="clearAllData()">Reset All</button>
        </div>
    </div>

    <div id="sticky-header-group">
        <div id="display">0</div>
        <span id="slideLabel" contenteditable="true" role="textbox" data-placeholder="Header..."></span>
        
        <div id="pdf-render-container">
            <div id="no-pdf-msg">Load PDF in Settings (⚙)</div>
            <canvas id="the-canvas"></canvas>
            <canvas id="draw-canvas"></canvas>
        </div>
    </div>

    <div id="notes-container">
        <div id="slideNotes" contenteditable="true" role="textbox" data-placeholder="Start typing notes..."></div>
    </div>

    <script>
        // --- STATE ---
        const savedData = localStorage.getItem('slideTrackerData_Fixed_Offsets'); 
        let state = savedData ? JSON.parse(savedData) : { count: 0, memory: {} };
        
        const MODES = ['NUM', 'PULSE', 'PDF'];
        let currentModeIndex = 0; 
        
        let pdfDoc = null;
        let renderTask = null;

        const pdfCanvas = document.getElementById('the-canvas');
        const drawCanvas = document.getElementById('draw-canvas');
        const pdfCtx = pdfCanvas.getContext('2d');
        const drawCtx = drawCanvas.getContext('2d');
        
        const display = document.getElementById('display');
        const slideLabel = document.getElementById('slideLabel');
        const slideNotes = document.getElementById('slideNotes');
        const pdfContainer = document.getElementById('pdf-render-container');
        const noPdfMsg = document.getElementById('no-pdf-msg');
        const modeStatus = document.getElementById('mode-status');
        const controlsPanel = document.getElementById('controls-panel');
        const drawingControls = document.getElementById('drawing-controls');
        const btnPen = document.getElementById('btn-pen');
        const btnEraser = document.getElementById('btn-eraser');
        
        let timeoutHandle = null;

        // Init
        updateUIForMode();
        updateDisplay();

        function saveData() {
            localStorage.setItem('slideTrackerData_Fixed_Offsets', JSON.stringify(state));
        }

        // --- DRAWING LOGIC ---
        let isDrawing = false;
        let isErasing = false;
        let currentTool = 'pen'; 
        let currentStrokes = []; 

        function setTool(tool) {
            currentTool = tool;
            if(tool === 'pen') {
                btnPen.classList.add('active');
                btnEraser.classList.remove('active');
                drawCanvas.style.cursor = 'crosshair';
            } else {
                btnPen.classList.remove('active');
                btnEraser.classList.add('active');
                drawCanvas.style.cursor = 'cell'; 
            }
        }

        function clearSlideDrawing() {
            if(confirm("Clear drawings for this slide?")) {
                if (state.memory[state.count]) {
                    state.memory[state.count].drawings = [];
                    saveData();
                    renderDrawings();
                }
            }
        }

        // --- CRITICAL FIX: ACCURATE MOUSE POSITION ---
        // This calculates position relative to the visual canvas, then normalizes (0-1)
        function getNormalizedPos(e) {
            const rect = drawCanvas.getBoundingClientRect();
            return {
                x: (e.clientX - rect.left) / rect.width,
                y: (e.clientY - rect.top) / rect.height
            };
        }

        // Converts Normalized (0-1) to Internal Canvas Pixels
        function toPixel(xNorm, yNorm) {
            return { 
                x: xNorm * drawCanvas.width, 
                y: yNorm * drawCanvas.height 
            };
        }

        drawCanvas.addEventListener('mousedown', (e) => {
            const norm = getNormalizedPos(e);
            
            if (currentTool === 'eraser') {
                isErasing = true;
                // We must calculate internal pixel for eraser check logic
                const px = toPixel(norm.x, norm.y);
                eraseStrokeAtInternal(px.x, px.y);
            } else {
                isDrawing = true;
                currentStrokes.push({ points: [norm] });
                
                const px = toPixel(norm.x, norm.y);
                
                drawCtx.lineWidth = 3;
                drawCtx.strokeStyle = 'red';
                drawCtx.lineCap = 'round';
                drawCtx.beginPath();
                drawCtx.moveTo(px.x, px.y);
                drawCtx.lineTo(px.x, px.y);
                drawCtx.stroke();
            }
        });

        drawCanvas.addEventListener('mousemove', (e) => {
            const norm = getNormalizedPos(e);
            const px = toPixel(norm.x, norm.y);

            if (currentTool === 'eraser' && isErasing) {
                eraseStrokeAtInternal(px.x, px.y);
                return;
            }

            if (currentTool === 'pen' && isDrawing) {
                const currentPath = currentStrokes[currentStrokes.length - 1];
                const lastNorm = currentPath.points[currentPath.points.length - 1];
                const lastPx = toPixel(lastNorm.x, lastNorm.y);

                drawCtx.lineWidth = 3;
                drawCtx.strokeStyle = 'red';
                drawCtx.lineCap = 'round';
                drawCtx.beginPath();
                drawCtx.moveTo(lastPx.x, lastPx.y);
                drawCtx.lineTo(px.x, px.y);
                drawCtx.stroke();

                currentPath.points.push(norm);
            }
        });

        drawCanvas.addEventListener('mouseup', endAction);
        drawCanvas.addEventListener('mouseout', endAction);

        function endAction() {
            if(isDrawing) {
                isDrawing = false;
                saveDrawingsToState();
            }
            if(isErasing) {
                isErasing = false;
            }
        }

        function eraseStrokeAtInternal(internalX, internalY) {
            const data = state.memory[state.count] || {};
            const drawings = data.drawings || [];
            if(drawings.length === 0) return;

            // Adjust eraser radius based on scale (canvas width / visible width roughly)
            // Or just pick a generous internal pixel size
            const eraserRadius = 25; 

            const remainingDrawings = drawings.filter(path => {
                const isTouched = path.points.some(ptNorm => {
                    const ptPx = toPixel(ptNorm.x, ptNorm.y);
                    const dist = Math.hypot(ptPx.x - internalX, ptPx.y - internalY);
                    return dist < eraserRadius;
                });
                return !isTouched; 
            });

            if(remainingDrawings.length !== drawings.length) {
                state.memory[state.count].drawings = remainingDrawings;
                saveData();
                renderDrawings();
            }
        }

        function saveDrawingsToState() {
            if (!state.memory[state.count]) state.memory[state.count] = {};
            const existing = state.memory[state.count].drawings || [];
            state.memory[state.count].drawings = existing.concat(currentStrokes);
            currentStrokes = []; 
            saveData();
        }

        function renderDrawings() {
            drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
            const data = state.memory[state.count] || {};
            const drawings = data.drawings || [];

            drawings.forEach(path => {
                drawCtx.strokeStyle = 'red';
                drawCtx.lineWidth = 3;
                drawCtx.lineCap = 'round';
                drawCtx.lineJoin = 'round';
                
                if (path.points.length < 1) return;

                drawCtx.beginPath();
                const start = toPixel(path.points[0].x, path.points[0].y);
                drawCtx.moveTo(start.x, start.y);

                for (let i = 1; i < path.points.length; i++) {
                    const pt = toPixel(path.points[i].x, path.points[i].y);
                    drawCtx.lineTo(pt.x, pt.y);
                }
                drawCtx.stroke();
            });
        }
        
        function resizeDrawLayer() {
            drawCanvas.width = pdfCanvas.width;
            drawCanvas.height = pdfCanvas.height;
            renderDrawings();
        }


        // --- APP LOGIC ---

        function handleInput() {
            if (!state.memory[state.count]) state.memory[state.count] = {};
            state.memory[state.count].header = slideLabel.innerText;
            state.memory[state.count].notes = slideNotes.innerText;
            saveData();
        }
        slideLabel.addEventListener('input', handleInput);
        slideNotes.addEventListener('input', handleInput);
        slideLabel.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); slideLabel.blur(); }});

        function handleNav(direction) {
            const mode = MODES[currentModeIndex];
            if (direction === 'forward') {
                state.count++;
                if (mode === 'PULSE') triggerFlash(">>>");
            } else if (direction === 'backward') {
                if (state.count > 0) {
                    state.count--;
                    if (mode === 'PULSE') triggerFlash("<<<");
                }
            }
            saveData();
            updateDisplay();

            if (mode === 'PDF' && pdfDoc) {
                renderPage(state.count + 1);
            }
        }

        function updateDisplay() {
            const mode = MODES[currentModeIndex];
            const data = state.memory[state.count] || {};

            if (mode !== 'PDF') slideLabel.innerText = data.header || "";
            slideNotes.innerText = data.notes || "";

            if (mode === 'NUM' || mode === 'PDF') {
                display.textContent = state.count;
                display.style.color = "white";
            } else if (mode === 'PULSE') {
                if (!timeoutHandle) {
                    display.textContent = "---";
                    display.style.color = "#333";
                }
            }
        }

        function triggerFlash(symbol) {
            if (timeoutHandle) clearTimeout(timeoutHandle);
            display.textContent = symbol;
            display.style.color = "white"; 
            timeoutHandle = setTimeout(() => {
                display.textContent = "---";
                display.style.color = "#333"; 
                timeoutHandle = null;
            }, 500);
        }

        function cycleMode() {
            currentModeIndex = (currentModeIndex + 1) % MODES.length;
            updateUIForMode();
            if (MODES[currentModeIndex] === 'PDF' && pdfDoc) {
                renderPage(state.count + 1);
            }
        }

        function updateUIForMode() {
            const mode = MODES[currentModeIndex];
            if (mode === 'PDF') {
                slideLabel.style.display = 'none';
                pdfContainer.style.display = 'flex';
                modeStatus.textContent = "Mode: PDF Slides";
                drawCanvas.classList.add('active');
                drawingControls.style.display = 'flex';
                setTool('pen'); 
            } else {
                slideLabel.style.display = 'block';
                pdfContainer.style.display = 'none';
                modeStatus.textContent = (mode === 'NUM') ? "Mode: Standard" : "Mode: No Numbers";
                drawCanvas.classList.remove('active');
                drawingControls.style.display = 'none';
            }
            if(timeoutHandle) { clearTimeout(timeoutHandle); timeoutHandle = null; }
            updateDisplay(); 
        }

        // --- PDF ENGINE ---
        document.getElementById('pdf-upload').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file && file.type === "application/pdf") {
                const fileReader = new FileReader();
                fileReader.onload = function() {
                    const typedarray = new Uint8Array(this.result);
                    pdfjsLib.getDocument(typedarray).promise.then(function(pdfDoc_) {
                        pdfDoc = pdfDoc_;
                        noPdfMsg.style.display = "none";
                        // Auto switch logic if not already default
                        if (MODES[currentModeIndex] === 'PDF') renderPage(state.count + 1);
                    });
                };
                fileReader.readAsArrayBuffer(file);
            }
        });

        function renderPage(num) {
            if (renderTask) renderTask.cancel();
            if (!pdfDoc || num < 1 || num > pdfDoc.numPages) return;

            pdfDoc.getPage(num).then(function(page) {
                const containerHeight = pdfContainer.clientHeight;
                const unscaledViewport = page.getViewport({scale: 1});
                const scale = containerHeight / unscaledViewport.height;
                const viewport = page.getViewport({scale: scale});

                pdfCanvas.height = viewport.height;
                pdfCanvas.width = viewport.width;

                resizeDrawLayer();

                const renderContext = { canvasContext: pdfCtx, viewport: viewport };
                renderTask = page.render(renderContext);
                renderTask.promise.then(() => { renderTask = null; })
                .catch((err) => { if(err.name !== 'RenderingCancelledException') console.log(err); });
            });
        }

        // --- JSON EXPORT ---
        function exportNotes() {
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(state));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            const date = new Date().toISOString().slice(0,10); 
            downloadAnchorNode.setAttribute("download", "lecture_notes_" + date + ".json");
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        }

        document.getElementById('json-upload').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(event) {
                try {
                    state = JSON.parse(event.target.result);
                    saveData();
                    updateDisplay();
                    if(pdfDoc && MODES[currentModeIndex] === 'PDF') renderPage(state.count + 1);
                    alert("Notes & Drawings loaded!");
                } catch(err) { alert("Error reading JSON"); }
            };
            reader.readAsText(file);
        });

        // --- UTILS ---
        function toggleMenu() { controlsPanel.classList.toggle('active'); }
        function updateNumberSize(val) { display.style.fontSize = val + "px"; }
        function updateTextSize(val) {
            slideNotes.style.fontSize = val + "px";
            slideLabel.style.fontSize = (val * 1.5) + "px";
        }
        function updatePdfSize(val) { pdfContainer.style.height = val + "vh"; }
        function refreshPdfResolution() {
            if (MODES[currentModeIndex] === 'PDF' && pdfDoc) renderPage(state.count + 1);
        }
        function clearAllData() {
            if(confirm("Reset all?")) {
                state = { count: 0, memory: {} };
                saveData();
                updateDisplay();
                if(pdfDoc) renderPage(1);
            }
        }

        // --- KEYS ---
        document.addEventListener('keydown', e => {
            if (e.key === 'Escape') { document.activeElement.blur(); return; }
            if (e.ctrlKey || e.metaKey) {
                if (e.key === 'ArrowUp' || e.key === 'ArrowRight') { e.preventDefault(); handleNav('forward'); return; }
                if (e.key === 'ArrowDown' || e.key === 'ArrowLeft') { e.preventDefault(); handleNav('backward'); return; }
            }
            if (document.activeElement === slideNotes) return;
            if (document.activeElement === slideLabel) {
                 if (['ArrowUp','ArrowDown'].includes(e.key)) {
                    e.preventDefault(); 
                    handleNav(e.key === 'ArrowUp' ? 'forward' : 'backward');
                 }
                 return;
            }
            if(e.key === 'ArrowUp' || e.key === 'ArrowRight') handleNav('forward');
            else if(e.key === 'ArrowDown' || e.key === 'ArrowLeft') handleNav('backward');
        });
    </script>
</body>
</html>