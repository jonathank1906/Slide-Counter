<!DOCTYPE html>
<html>
<head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/9.1.6/marked.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js"></script>

    <style>
        * { box-sizing: border-box; }
        body { margin: 0; height: 100vh; font-family: Arial, sans-serif; background-color: black; color: white; overflow: hidden; display: flex; flex-direction: column; }
        
        /* --- HEADER --- */
        #sticky-header-group { flex: 0 0 auto; background: #000; border-bottom: 1px solid #222; padding: 10px 20px; z-index: 50; position: relative; display: flex; flex-direction: column; justify-content: center; align-items: center; min-height: 100px; }
        #display { position: absolute; right: 20px; top: 50%; transform: translateY(-50%); font-size: 80px; font-weight: bold; user-select: none; line-height: 1; white-space: nowrap; text-align: right; z-index: 20; text-shadow: 0 0 5px black; }
        #slideLabel { background: transparent; border-bottom: 1px solid #333; color: #ddd; font-size: 30px; outline: none; padding-bottom: 2px; margin-bottom: 10px; min-width: 200px; max-width: 60%; text-align: center; transition: border-color 0.2s; cursor: text; display: block; }
        #slideLabel:focus { border-bottom: 1px solid #fff; }
        
        /* --- SIDEBAR NAVIGATOR --- */
        #sidebar-toggle { position: absolute; top: 10px; left: 50px; z-index: 101; background: transparent; border: none; font-size: 24px; cursor: pointer; color: #555; }
        #sidebar-toggle:hover { color: #fff; }
        
        #sidebar {
            position: absolute; top: 0; left: 0; width: 250px; height: 100%;
            background: #111; border-right: 1px solid #333; z-index: 90;
            transform: translateX(-100%); transition: transform 0.2s ease;
            display: flex; flex-direction: column; padding-top: 60px;
            /* RESIZE LOGIC */
            min-width: 150px; max-width: 80vw;
        }
        #sidebar.active { transform: translateX(0); }
        
        /* THE DRAG HANDLE */
        #resizer {
            width: 10px;
            height: 100%;
            position: absolute;
            right: 0;
            top: 0;
            cursor: col-resize;
            z-index: 100;
            background: transparent;
        }
        #resizer:hover { background: rgba(255, 255, 255, 0.1); }

        #toc-list { overflow-y: auto; flex: 1; padding: 10px; }
        #toc-list::-webkit-scrollbar { width: 5px; }
        #toc-list::-webkit-scrollbar-thumb { background: #333; }
        
        .toc-item {
            padding: 8px; border-bottom: 1px solid #222; cursor: pointer;
            font-size: 13px; color: #aaa; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
            display: flex; align-items: center; gap: 10px;
        }
        .toc-item:hover { background: #333; color: #fff; }
        .toc-item.current { background: #333; color: #fff; border-left: 3px solid #fff; }
        
        /* STANDARD NUMBER */
        .toc-num { font-weight: bold; min-width: 25px; text-align: right; }

        /* GRAYSCALE FRIENDLY: CIRCLE STYLE FOR NOTES */
        .toc-item.is-note .toc-num {
            background: #ddd;
            color: #000;
            border-radius: 50%;
            width: 22px;
            height: 22px;
            min-width: 22px; 
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-size: 11px;
            margin-right: 3px;
        }
        .toc-item.is-note { color: #aaa; } 
        .toc-item.is-note:hover { color: #fff; }

        /* --- PDF & DRAWING --- */
        #pdf-render-container { display: none; justify-content: center; align-items: center; width: 100%; height: 30vh; position: relative; transition: height 0.1s ease; }
        #the-canvas { max-height: 100%; max-width: 80%; border: 1px solid #333; box-shadow: 0 0 20px rgba(0,0,0,0.5); position: absolute; z-index: 1; }
        #the-canvas.inverted { filter: invert(1); }
        #draw-canvas { max-height: 100%; max-width: 80%; position: absolute; z-index: 2; touch-action: none; pointer-events: none; }
        #draw-canvas.active { pointer-events: auto; border: 1px dashed rgba(255, 255, 255, 0.2); }
        #no-pdf-msg { color: #444; font-style: italic; position: absolute; font-size: 14px; z-index: 0; }
        
        /* --- NOTES --- */
        #notes-container { flex: 1; position: relative; overflow: hidden; display: flex; justify-content: center; border-top: 1px solid #111; background: #050505; }
        #notes-wrapper { width: 100%; max-width: 800px; height: 100%; padding: 20px; overflow-y: auto; position: relative; }
        #notes-wrapper::-webkit-scrollbar { width: 10px; }
        #notes-wrapper::-webkit-scrollbar-track { background: #111; }
        #notes-wrapper::-webkit-scrollbar-thumb { background: #333; border-radius: 5px; }
        #slideNotesEditor { width: 100%; min-height: 100%; background: transparent; border: none; color: #aaa; font-size: 18px; text-align: left; outline: none; font-family: 'Consolas', 'Courier New', monospace; resize: none; line-height: 1.6; display: none; tab-size: 4; }
        #slideNotesPreview { width: 100%; min-height: 100%; color: #ddd; font-size: 18px; line-height: 1.6; display: block; cursor: text; }
        #slideNotesPreview h1, #slideNotesPreview h2, #slideNotesPreview h3 { color: #fff; margin-top: 20px; border-bottom: 1px solid #333; padding-bottom: 5px; }
        #slideNotesPreview ul, #slideNotesPreview ol { padding-left: 25px; margin-bottom: 10px; }
        #slideNotesPreview p { margin-bottom: 10px; }
        #slideNotesPreview blockquote { border-left: 4px solid #888; margin: 10px 0; padding-left: 15px; color: #aaa; font-style: italic; background: #111; padding: 5px;}
        #slideNotesPreview a { color: #fff; text-decoration: underline; }
        mark { background-color: #fff; color: black; border-radius: 2px; padding: 0 2px; font-weight: bold; }
        #slideNotesPreview pre { background: #1e1e1e !important; padding: 10px; border-radius: 6px; overflow-x: auto; border: 1px solid #333; margin: 10px 0; }
        #slideNotesPreview code { font-family: 'Consolas', 'Courier New', monospace; font-size: 15px; }
        #slideNotesPreview :not(pre) > code { background: #2d2d2d; padding: 2px 5px; border-radius: 4px; color: #ccc; border: 1px solid #444; }
        #slideNotesPreview table { border-collapse: collapse; width: 100%; margin: 15px 0; font-size: 16px; border: 1px solid #444; }
        #slideNotesPreview th, #slideNotesPreview td { border: 1px solid #444; padding: 8px 12px; text-align: left; }
        #slideNotesPreview th { background-color: #222; color: #fff; font-weight: bold; }
        #slideNotesPreview tr:nth-child(even) { background-color: #111; }
        #slideNotesPreview tr:nth-child(odd) { background-color: #161616; }
        
        /* --- SETTINGS MENU (GRAYSCALE OPTIMIZED) --- */
        #menu-container { position: absolute; top: 10px; left: 10px; z-index: 100; }
        #gear-btn { background: transparent; color: #555; border: none; font-size: 24px; cursor: pointer; padding: 5px; transition: color 0.2s; }
        #gear-btn:hover { color: #fff; }
        
        #controls-panel { display: none; margin-top: 5px; background: #111; padding: 15px; border-radius: 8px; border: 1px solid #333; flex-direction: column; gap: 15px; width: 300px; }
        #controls-panel.active { display: flex; }
        
        /* GENERIC BUTTON STYLES (MONOCHROME) */
        button { font-family: inherit; }
        button.action-btn, .slide-ops button, .search-nav-btn, #clear-search-btn {
            padding: 8px; font-size: 12px; cursor: pointer; 
            background: #000; color: #ccc; 
            border: 1px solid #444; border-radius: 4px;
            transition: all 0.1s;
        }
        button.action-btn:hover, .slide-ops button:hover, .search-nav-btn:hover {
            background: #333; color: #fff; border-color: #888;
        }
        
        /* TOOLBAR */
        .toolbar { display: flex; gap: 5px; background: #222; padding: 5px; border-radius: 5px; }
        .tool-btn { flex: 1; padding: 5px; font-size: 11px; cursor: pointer; background: #000; color: #888; border: 1px solid #444; border-radius: 3px; }
        .tool-btn:hover { background: #333; color: #fff; }
        /* Active Tool = White Background, Black Text */
        .tool-btn.active { background: #ddd; color: #000; border-color: #fff; font-weight: bold; }
        
        /* SEARCH */
        .search-group { display: flex; gap: 5px; align-items: center; }
        #search-input { flex: 1; background: #000; border: 1px solid #444; color: white; padding: 6px; font-size: 12px; border-radius: 4px; outline: none; }
        #search-input:focus { border-color: #888; }
        #search-count { font-size: 10px; color: #666; min-width: 40px; text-align: center; }
        #clear-search-btn { border: none; font-size: 14px; padding: 0 5px; }
        #clear-search-btn:hover { color: #fff; }
        
        .slide-ops { display: flex; gap: 5px; }
        
        /* INPUTS & LABELS */
        .control-group { display: flex; flex-direction: column; gap: 5px; }
        label { font-size: 12px; color: #888; } /* Standard gray labels */
        input[type=range] { width: 100%; cursor: pointer; accent-color: #888; }
        input[type=file] { font-size: 12px; color: #aaa; }
        
        #mode-status { color: #aaa; font-size: 12px; font-weight: bold; }
        .empty-placeholder { color: #444; font-style: italic; }
        
        /* CHECKBOX */
        .checkbox-container { display: flex; align-items: center; margin-top: 5px; cursor: pointer; }
        .checkbox-container input { margin-right: 8px; cursor: pointer; accent-color: #888; }
        .checkbox-text { font-size: 12px; color: #ccc; }
    </style>
</head>
<body>

    <div id="sidebar">
        <div id="resizer"></div> <div style="padding:10px; font-weight:bold; color:#fff; border-bottom:1px solid #333;">Slides / Notes</div>
        <div id="toc-list"></div>
    </div>
    <button id="sidebar-toggle" onclick="toggleSidebar()">‚ò∞</button>

    <div id="menu-container">
        <button id="gear-btn" onclick="toggleMenu()">‚öô</button>
        <div id="controls-panel">
            <div class="control-group">
                <div id="mode-status">Mode: Standard</div>
                <button class="action-btn" onclick="cycleMode()">Switch Mode</button>
            </div>
            
            <div class="control-group">
                <label>Slide Manager</label>
                <div class="slide-ops">
                    <button onclick="insertSlide(-1)">+ Blank Before</button>
                    <button onclick="insertSlide(1)">+ Blank After</button>
                </div>
                <div class="slide-ops">
                    <button class="del-btn" onclick="deleteCurrentSlide()">Delete Current</button>
                </div>
                <label style="margin-top:5px;">Shift Content (Fix Offset)</label>
                <div class="slide-ops">
                    <button onclick="shiftContent(-1)" title="Moves text from Slide 2 to Slide 1">‚ñ≤ Shift Up</button>
                    <button onclick="shiftContent(1)" title="Moves text from Slide 1 to Slide 2">‚ñº Shift Down</button>
                </div>
                <button id="sync-btn" class="action-btn" onclick="syncPdfSlides()">‚ôªÔ∏è Sync Slides to PDF (1:1)</button>
            </div>

            <div class="control-group">
                <label>Search (Ctrl+F)</label>
                <div class="search-group">
                    <input type="text" id="search-input" placeholder="Find..." oninput="performSearch()">
                    <button id="clear-search-btn" title="Clear Search" onclick="clearSearch()">‚úñ</button>
                    <div id="search-count">0/0</div>
                </div>
                <div class="search-group">
                    <button class="search-nav-btn" style="flex:1" onclick="nextMatch(-1)">Prev</button>
                    <button class="search-nav-btn" style="flex:1" onclick="nextMatch(1)">Next</button>
                </div>
            </div>
            <div class="control-group" id="drawing-controls" style="display:none;">
                <label>Drawing Tools</label>
                <div class="toolbar">
                    <button class="tool-btn active" id="btn-pen" onclick="setTool('pen')">Pen</button>
                    <button class="tool-btn" id="btn-eraser" onclick="setTool('eraser')">Stroke Eraser</button>
                    <button class="tool-btn" onclick="clearSlideDrawing()">Clear Slide</button>
                </div>
            </div>
            <hr style="width:100%; border:0; border-top:1px solid #333;">
            <div class="control-group"><label>1. Load Slides (PDF)</label><input type="file" id="pdf-upload" accept=".pdf" autocomplete="off"></div>
            
            <div class="control-group">
                <label>2. Import Notes</label>
                <button id="open-btn" class="action-btn" onclick="openNotesEditable()">üìÇ Open (Keep Saved Link)</button>
                <div style="font-size:10px; color:#666; margin-top:2px;">OR</div>
                <input type="file" id="json-upload" accept=".json" autocomplete="off">
            </div>

            <div class="control-group">
                <button id="export-btn" class="action-btn" onclick="saveNotes()">üíæ Save (Instant)</button>
                <button id="save-as-btn" class="action-btn" onclick="saveNotesAs()">Save As New File...</button>
                
                <label class="checkbox-container">
                    <input type="checkbox" id="autosave-toggle" onchange="toggleAutoSave()" checked>
                    <span class="checkbox-text">Enable Auto-Save (Every 2 min)</span>
                </label>
            </div>
            <div class="control-group"><button id="panic-btn" class="action-btn" onclick="recoverLostText()">üÜò Restore Lost Text</button></div>
            <hr style="width:100%; border:0; border-top:1px solid #333;">
            <div class="control-group"><label>Number Size</label><input type="range" min="20" max="120" value="80" oninput="updateNumberSize(this.value)"></div>
            <div class="control-group"><label>Text Size</label><input type="range" min="12" max="60" value="18" oninput="updateTextSize(this.value)"></div>
            <div class="control-group"><label>PDF Preview Size</label><input type="range" min="10" max="90" value="30" oninput="updatePdfSize(this.value)" onchange="refreshPdfResolution()"></div>
            <button id="clear-data-btn" class="action-btn" onclick="clearAllData()">Reset All</button>
        </div>
    </div>

    <div id="sticky-header-group">
        <div id="display">1</div>
        <span id="slideLabel" contenteditable="true" role="textbox" data-placeholder="Header..."></span>
        <div id="pdf-render-container">
            <div id="no-pdf-msg">Load PDF in Settings (‚öô)</div>
            <canvas id="the-canvas"></canvas>
            <canvas id="draw-canvas"></canvas>
        </div>
    </div>

    <div id="notes-container">
        <div id="notes-wrapper">
            <textarea id="slideNotesEditor" placeholder="Type Markdown here... (Math: $x^2$, Code: ```js ...)"></textarea>
            <div id="slideNotesPreview" onclick="activateEditor()"></div>
        </div>
    </div>

    <script>
        // ==========================================
        // 1. GLOBAL VARIABLES
        // ==========================================
        const pdfCanvas = document.getElementById('the-canvas');
        const drawCanvas = document.getElementById('draw-canvas');
        const pdfCtx = pdfCanvas.getContext('2d');
        const drawCtx = drawCanvas.getContext('2d');
        const display = document.getElementById('display');
        const slideLabel = document.getElementById('slideLabel');
        const editor = document.getElementById('slideNotesEditor');
        const preview = document.getElementById('slideNotesPreview');
        const pdfContainer = document.getElementById('pdf-render-container');
        const noPdfMsg = document.getElementById('no-pdf-msg');
        const modeStatus = document.getElementById('mode-status');
        const controlsPanel = document.getElementById('controls-panel');
        const drawingControls = document.getElementById('drawing-controls');
        const btnPen = document.getElementById('btn-pen');
        const btnEraser = document.getElementById('btn-eraser');
        const searchInput = document.getElementById('search-input');
        const searchCount = document.getElementById('search-count');
        const sidebar = document.getElementById('sidebar');
        const tocList = document.getElementById('toc-list');
        const resizer = document.getElementById('resizer');

        const offscreenCanvas = document.createElement('canvas');
        const offscreenCtx = offscreenCanvas.getContext('2d');

        try {
            marked.setOptions({
                highlight: function(code, lang) {
                    if (lang && hljs.getLanguage(lang)) { return hljs.highlight(code, { language: lang }).value; }
                    return hljs.highlightAuto(code).value;
                },
                langPrefix: 'hljs language-'
            });
        } catch(e) { console.error("Marked/HLJS not loaded", e); }

        let state = { count: 1, slides: [] };
        state.slides = [{ type: 'blank', header: '', notes: '', drawings: [] }];
        
        let MODES = ['NUM', 'PULSE', 'PDF'];
        let currentModeIndex = 0; 
        let pdfDoc = null;
        let renderTask = null;
        let searchMatches = []; 
        let currentMatchPos = -1;
        let timeoutHandle = null;
        let isEditorActive = false;

        let historyStacks = {}; 
        let saveTimeout = null;
        let isRestoring = false;
        let emergencyBackup = ""; 
        let fileHandle = null;
        let autoSaveInterval = null;

        let isDrawing = false; let isErasing = false; let currentTool = 'pen'; let currentStrokes = [];
        let isPageRendering = false; let pageNumPending = null;

        // ==========================================
        // 2. HELPER FUNCTIONS
        // ==========================================

        function getHistory(index) {
            if (!historyStacks[index]) historyStacks[index] = { undo: [], redo: [] };
            return historyStacks[index];
        }

        function pushSnapshot(index, text) {
            if (isRestoring) return;
            const h = getHistory(index);
            if (h.undo.length > 0 && h.undo[h.undo.length - 1] === text) return;
            h.undo.push(text);
            h.redo = []; 
            if (h.undo.length > 50) h.undo.shift(); 
        }

        function undo(index) {
            const h = getHistory(index);
            if (h.undo.length === 0) return null;
            const currentText = editor.value;
            if (h.undo.length > 0 && h.undo[h.undo.length - 1] === currentText) {
                h.undo.pop();
            }
            if (h.undo.length === 0) return null;
            h.redo.push(currentText); 
            const prev = h.undo.pop();
            return prev;
        }

        function redo(index) {
            const h = getHistory(index);
            if (h.redo.length === 0) return null;
            const next = h.redo.pop();
            h.undo.push(editor.value);
            return next;
        }

        function recoverLostText() {
            if (emergencyBackup) {
                if(confirm("Restore the last mass-deleted text from memory?")) {
                    editor.value = emergencyBackup + "\n" + editor.value;
                    handleInput();
                }
            } else { alert("No lost text found in memory."); }
        }

        function checkIfDirty() {
            if (state.slides.length > 1) return true; 
            const s = state.slides[0];
            if (s.header && s.header.trim() !== "") return true;
            if (s.notes && s.notes.trim() !== "") return true;
            if (s.drawings && s.drawings.length > 0) return true;
            return false;
        }

        function saveData() { /* Memory Only */ }

        function handleInput() {
            const idx = state.count - 1;
            const newText = editor.value;
            const oldText = state.slides[idx] ? state.slides[idx].notes : "";
            if (oldText && oldText.length > 20 && newText.length < 5) {
                emergencyBackup = oldText;
            }
            if(!state.slides[idx]) state.slides[idx] = { type:'blank', header:'', notes:'', drawings:[] };
            state.slides[idx].header = slideLabel.innerText;
            state.slides[idx].notes = newText; 
            
            if (saveTimeout) clearTimeout(saveTimeout);
            saveTimeout = setTimeout(() => {
                pushSnapshot(idx, newText); 
            }, 500);
            saveData();
            updateSidebar(); 
        }

        function updateDisplay() {
            const idx = state.count - 1;
            const slide = state.slides[idx] || { type:'blank', header:'', notes:'' };
            slideLabel.innerText = slide.header || "";
            editor.value = slide.notes || "";
            
            if (!historyStacks[idx]) historyStacks[idx] = { undo: [], redo: [] };

            const noteText = (slide.notes === undefined || slide.notes === null) ? "" : slide.notes;
            let htmlContent = "";
            if (typeof marked !== 'undefined') {
                htmlContent = noteText.trim() ? marked.parse(noteText) : '<span class="empty-placeholder">Click to add notes...</span>';
            } else htmlContent = noteText;

            const term = searchInput.value.trim();
            if (term.length > 0) {
                const regex = new RegExp(`(${term})`, 'gi');
                htmlContent = htmlContent.replace(regex, '<mark>$1</mark>');
            }
            preview.innerHTML = htmlContent;

            if (typeof renderMathInElement !== 'undefined') {
                renderMathInElement(preview, { delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}], throwOnError: false });
            }

            const mode = MODES[currentModeIndex];
            
            if (mode === 'PDF') {
                if (slide.type === 'blank') {
                    pdfContainer.style.display = 'none';
                } else {
                    pdfContainer.style.display = 'flex';
                    if (pdfCanvas.width === 0 && pdfDoc) renderPage();
                }
            }

            if (mode === 'NUM' || mode === 'PDF') { display.textContent = state.count; display.style.color = "white"; } 
            else if (mode === 'PULSE') { if (!timeoutHandle) { display.textContent = "---"; display.style.color = "#333"; } }
            
            updateSidebar();
        }

        // --- SIDEBAR LOGIC ---
        function toggleSidebar() {
            sidebar.classList.toggle('active');
        }

        function updateSidebar() {
            let html = "";
            state.slides.forEach((slide, index) => {
                const num = index + 1;
                const isCurrent = (num === state.count);
                const isBlank = (slide.type === 'blank');
                const title = slide.header ? slide.header : (isBlank ? "<i>(Note Slide)</i>" : `Slide ${num}`);
                
                html += `<div class="toc-item ${isCurrent ? 'current' : ''} ${isBlank ? 'is-note' : ''}" onclick="jumpToSlide(${num})">
                    <span class="toc-num">${num}</span>
                    <span class="toc-text">${title}</span>
                </div>`;
            });
            tocList.innerHTML = html;
        }

        function jumpToSlide(num) {
            if (isEditorActive) activatePreview();
            state.count = num;
            updateDisplay();
            if (MODES[currentModeIndex] === 'PDF') renderPage();
        }

        // --- SIDEBAR RESIZE LOGIC ---
        let isResizing = false;
        resizer.addEventListener('mousedown', (e) => {
            isResizing = true;
            document.body.style.cursor = 'col-resize';
            e.preventDefault();
        });
        document.addEventListener('mousemove', (e) => {
            if (!isResizing) return;
            let newWidth = e.clientX;
            // Limits
            if (newWidth < 150) newWidth = 150;
            if (newWidth > window.innerWidth * 0.8) newWidth = window.innerWidth * 0.8;
            sidebar.style.width = newWidth + 'px';
        });
        document.addEventListener('mouseup', () => {
            if(isResizing) {
                isResizing = false;
                document.body.style.cursor = 'default';
            }
        });

        function updateUIForMode() {
            const mode = MODES[currentModeIndex];
            if (mode === 'PDF') {
                slideLabel.style.display = 'block'; pdfContainer.style.display = 'flex'; modeStatus.textContent = "Mode: PDF Slides";
                drawCanvas.classList.add('active'); drawingControls.style.display = 'flex'; setTool('pen'); 
            } else {
                slideLabel.style.display = 'block'; pdfContainer.style.display = 'none'; modeStatus.textContent = (mode === 'NUM') ? "Mode: Standard" : "Mode: No Numbers";
                drawCanvas.classList.remove('active'); drawingControls.style.display = 'none';
            }
            if(timeoutHandle) { clearTimeout(timeoutHandle); timeoutHandle = null; }
            updateDisplay(); 
        }

        function renderPage() {
            if (pdfContainer.clientHeight === 0) return; 
            if (renderTask) renderTask.cancel();
            const slide = state.slides[state.count - 1];
            
            if (!slide || slide.type === 'blank') {
                if(isPageRendering) {
                    if(renderTask) { renderTask.cancel(); renderTask = null; }
                    isPageRendering = false; pageNumPending = null;
                }
                pdfCtx.clearRect(0,0,pdfCanvas.width,pdfCanvas.height);
                // Visual placeholder
                if(pdfCanvas.width < 100) { pdfCanvas.width=800; pdfCanvas.height=450; } 
                
                const isDark = pdfCanvas.classList.contains('inverted');
                pdfCtx.fillStyle = isDark ? '#333' : '#eee';
                pdfCtx.fillRect(0,0,pdfCanvas.width, pdfCanvas.height);
                
                pdfCtx.font = "30px Arial";
                pdfCtx.fillStyle = isDark ? '#fff' : '#555';
                pdfCtx.textAlign = "center";
                pdfCtx.fillText("üìù Additional Notes (Not in PDF)", pdfCanvas.width/2, pdfCanvas.height/2);
                
                resizeDrawLayer(); return;
            }
            if (!pdfDoc) return;

            const pageNum = slide.pdfPage || state.count;
            if(pageNum > pdfDoc.numPages) { pdfCtx.clearRect(0,0,pdfCanvas.width,pdfCanvas.height); return; }

            if (isPageRendering) {
                pageNumPending = pageNum;
                if (renderTask) { renderTask.cancel(); }
                return; 
            }

            isPageRendering = true;
            pdfDoc.getPage(pageNum).then(function(page) {
                const containerHeight = pdfContainer.clientHeight;
                const unscaledViewport = page.getViewport({scale: 1});
                const scale = containerHeight / unscaledViewport.height;
                const viewport = page.getViewport({scale: scale});
                
                offscreenCanvas.height = viewport.height;
                offscreenCanvas.width = viewport.width;

                const renderContext = { canvasContext: offscreenCtx, viewport: viewport };
                renderTask = page.render(renderContext);

                renderTask.promise.then(function() {
                    isPageRendering = false;
                    if (pageNumPending !== null) { 
                        pageNumPending = null; 
                        renderPage(); 
                    } else {
                        pdfCanvas.height = offscreenCanvas.height;
                        pdfCanvas.width = offscreenCanvas.width;
                        pdfCtx.drawImage(offscreenCanvas, 0, 0);
                        resizeDrawLayer();
                    }
                }).catch(function(err) {
                    isPageRendering = false;
                    if (err.name === 'RenderingCancelledException') {
                        if (pageNumPending !== null) { pageNumPending = null; renderPage(); }
                    } else { console.log(err); }
                });
            });
        }

        function triggerFlash(symbol) {
            if (timeoutHandle) clearTimeout(timeoutHandle);
            display.textContent = symbol; display.style.color = "white"; 
            timeoutHandle = setTimeout(() => { display.textContent = "---"; display.style.color = "#333"; timeoutHandle = null; }, 500);
        }

        function cycleMode() {
            currentModeIndex = (currentModeIndex + 1) % MODES.length;
            updateUIForMode();
            if (MODES[currentModeIndex] === 'PDF') renderPage();
        }

        function handleNav(direction) {
            if(isEditorActive) activatePreview();
            if (direction === 'forward') {
                if (state.count === state.slides.length) {
                    let nextType = 'blank'; let nextPdfPage = null;
                    if (pdfDoc) {
                        let lastPage = 0;
                        for(let i=state.slides.length-1; i>=0; i--) { if(state.slides[i].type === 'pdf') { lastPage = state.slides[i].pdfPage; break; } }
                        if(lastPage < pdfDoc.numPages) { nextType='pdf'; nextPdfPage = lastPage+1; }
                    }
                    state.slides.push({ type: nextType, pdfPage: nextPdfPage, header: "", notes: "", drawings: [] });
                }
                state.count++;
                if (MODES[currentModeIndex] === 'PULSE') triggerFlash(">>>");
            } else if (direction === 'backward') { 
                if (state.count > 1) { state.count--; if (MODES[currentModeIndex] === 'PULSE') triggerFlash("<<<"); } 
            }
            updateDisplay();
            if (MODES[currentModeIndex] === 'PDF') renderPage();
        }

        function setTool(tool) {
            currentTool = tool;
            if(tool === 'pen') { btnPen.classList.add('active'); btnEraser.classList.remove('active'); drawCanvas.style.cursor = 'crosshair'; } 
            else { btnPen.classList.remove('active'); btnEraser.classList.add('active'); drawCanvas.style.cursor = 'cell'; }
        }
        function clearSlideDrawing() {
            if(confirm("Clear drawings?")) {
                const s = state.slides[state.count - 1];
                if (s) { s.drawings = []; saveData(); renderDrawings(); }
            }
        }
        function toNorm(x, y) { return { x: x / drawCanvas.width, y: y / drawCanvas.height }; }
        function toPixel(xNorm, yNorm) { return { x: xNorm * drawCanvas.width, y: yNorm * drawCanvas.height }; }
        function getNormalizedPos(e) {
            const rect = drawCanvas.getBoundingClientRect();
            return { x: (e.clientX - rect.left) / rect.width, y: (e.clientY - rect.top) / rect.height };
        }
        function eraseStrokeAtInternal(pos) {
            const slide = state.slides[state.count - 1];
            const drawings = slide ? (slide.drawings || []) : [];
            if(drawings.length === 0) return;
            const remaining = drawings.filter(path => {
                return !path.points.some(pt => {
                    const pPx = toPixel(pt.x, pt.y);
                    return Math.hypot(pPx.x - pos.x, pPx.y - pos.y) < 25;
                });
            });
            if(remaining.length !== drawings.length) { slide.drawings = remaining; saveData(); renderDrawings(); }
        }
        function saveDrawingsToState() {
            const slide = state.slides[state.count - 1];
            if(slide) {
                if(!slide.drawings) slide.drawings = [];
                slide.drawings = slide.drawings.concat(currentStrokes);
                currentStrokes = []; saveData();
            }
        }
        function renderDrawings() {
            drawCtx.clearRect(0,0,drawCanvas.width,drawCanvas.height);
            const slide = state.slides[state.count - 1];
            const drawings = slide ? (slide.drawings || []) : [];
            drawings.forEach(path => {
                drawCtx.strokeStyle='red'; drawCtx.lineWidth=3; drawCtx.lineCap='round'; drawCtx.lineJoin='round'; if(path.points.length<1) return;
                drawCtx.beginPath(); const start = toPixel(path.points[0].x, path.points[0].y); drawCtx.moveTo(start.x, start.y);
                for(let i=1; i<path.points.length; i++) { const p = toPixel(path.points[i].x, path.points[i].y); drawCtx.lineTo(p.x, p.y); } drawCtx.stroke();
            });
        }
        function resizeDrawLayer() { drawCanvas.width = pdfCanvas.width; drawCanvas.height = pdfCanvas.height; renderDrawings(); }
        function endAction() { if(isDrawing) { isDrawing = false; saveDrawingsToState(); } if(isErasing) isErasing = false; }

        function insertSlide(offset) {
            handleInput();
            const newSlide = { type: 'blank', header: '', notes: '', drawings: [] };
            let insertIndex = (offset === 1) ? state.count : state.count - 1;
            state.slides.splice(insertIndex, 0, newSlide);
            if (offset === 1) state.count++; 
            updateDisplay();
            if (MODES[currentModeIndex] === 'PDF') renderPage();
        }
        function deleteCurrentSlide() {
            if (state.slides.length <= 1) { alert("Cannot delete the only slide."); return; }
            if (!confirm("Delete current slide?")) return;
            state.slides.splice(state.count - 1, 1);
            if (state.count > state.slides.length) state.count = state.slides.length;
            updateDisplay();
            if (MODES[currentModeIndex] === 'PDF') renderPage();
        }

        // --- NEW SYNC & SHIFT LOGIC ---
        function syncPdfSlides() {
            if (!pdfDoc) { alert("Load a PDF first."); return; }
            if (!confirm(`Force-Sync slides to PDF pages 1-${pdfDoc.numPages}? (Fixes black screens/missing slides)`)) return;
            
            for (let i = 0; i < pdfDoc.numPages; i++) {
                if (!state.slides[i]) {
                    state.slides[i] = { type: 'pdf', pdfPage: i + 1, header: "", notes: "", drawings: [] };
                } else {
                    state.slides[i].type = 'pdf';
                    state.slides[i].pdfPage = i + 1;
                }
            }
            if (state.count > state.slides.length) state.count = state.slides.length;
            updateDisplay();
            renderPage();
        }

        function shiftContent(direction) {
            if (!confirm(`Shift content ${direction === -1 ? 'UP (Delete Slide 1)' : 'DOWN (Insert Blank at 1)'}?`)) return;
            
            if (direction === 1) { // DOWN
                for (let i = state.slides.length - 1; i >= 0; i--) {
                    if (i === 0) {
                        state.slides[i].notes = ""; state.slides[i].drawings = []; state.slides[i].header = "";
                    } else {
                        state.slides[i].notes = state.slides[i-1].notes;
                        state.slides[i].drawings = state.slides[i-1].drawings;
                        state.slides[i].header = state.slides[i-1].header;
                    }
                }
            } else { // UP
                for (let i = 0; i < state.slides.length; i++) {
                    if (i === state.slides.length - 1) {
                        state.slides[i].notes = ""; state.slides[i].drawings = []; state.slides[i].header = "";
                    } else {
                        state.slides[i].notes = state.slides[i+1].notes;
                        state.slides[i].drawings = state.slides[i+1].drawings;
                        state.slides[i].header = state.slides[i+1].header;
                    }
                }
            }
            updateDisplay();
        }

        function performSearch() {
            const query = searchInput.value.toLowerCase().trim();
            searchMatches = [];
            currentMatchPos = -1;
            if (query.length === 0) { searchCount.textContent = "0/0"; updateDisplay(); return; }
            handleInput();
            state.slides.forEach((slide, index) => {
                const header = (slide.header || "").toLowerCase();
                const notes = (slide.notes || "").toLowerCase();
                if (header.includes(query) || notes.includes(query)) { searchMatches.push(index + 1); }
            });
            if (searchMatches.length > 0) {
                const upcoming = searchMatches.findIndex(num => num >= state.count);
                currentMatchPos = (upcoming !== -1) ? upcoming : 0;
                searchCount.textContent = `${currentMatchPos + 1}/${searchMatches.length}`;
            } else { searchCount.textContent = "0/0"; }
            updateDisplay();
        }
        function nextMatch(dir) {
            if (searchMatches.length === 0) return;
            if (state.count === searchMatches[currentMatchPos]) currentMatchPos += dir;
            if (currentMatchPos >= searchMatches.length) currentMatchPos = 0;
            if (currentMatchPos < 0) currentMatchPos = searchMatches.length - 1;
            searchCount.textContent = `${currentMatchPos + 1}/${searchMatches.length}`;
            state.count = searchMatches[currentMatchPos];
            updateDisplay();
            activatePreview(); 
            if (MODES[currentModeIndex] === 'PDF') renderPage();
        }
        function clearSearch() { searchInput.value = ""; performSearch(); searchInput.blur(); }

        async function openNotesEditable() {
            if (!window.showOpenFilePicker) { alert("Your browser doesn't support Smart Open. Use standard Import below."); return; }
            try {
                [fileHandle] = await window.showOpenFilePicker({
                    types: [{ description: 'JSON Notes', accept: {'application/json': ['.json']} }],
                });
                const file = await fileHandle.getFile();
                const text = await file.text();
                loadImportedData(text);
                document.getElementById('export-btn').textContent = "üíæ Save (Instant)";
                
                if (document.getElementById('autosave-toggle').checked) {
                    startAutoSave();
                }
            } catch(e) { console.error("Open cancelled", e); }
        }

        async function saveNotes() {
            const content = JSON.stringify(state);
            if (fileHandle) {
                try {
                    const writable = await fileHandle.createWritable();
                    await writable.write(content);
                    await writable.close();
                    
                    const btn = document.getElementById('export-btn');
                    if (!arguments[0]) { 
                        const orig = btn.textContent;
                        btn.textContent = "‚úÖ Saved!";
                        setTimeout(() => btn.textContent = orig, 2000);
                    } else {
                        const orig = btn.textContent;
                        btn.textContent = "‚úÖ Auto-Saved";
                        setTimeout(() => btn.textContent = orig, 1000);
                    }
                    return;
                } catch(e) { console.error("Save failed", e); fileHandle = null; }
            }
            if (!arguments[0]) saveNotesAs();
        }

        async function saveNotesAs() {
            const content = JSON.stringify(state);
            if (window.showSaveFilePicker) {
                try {
                    const date = new Date().toISOString().slice(0,10);
                    fileHandle = await window.showSaveFilePicker({
                        suggestedName: `lecture_notes_${date}.json`,
                        types: [{ description: 'JSON File', accept: {'application/json': ['.json']} }],
                    });
                    const writable = await fileHandle.createWritable();
                    await writable.write(content);
                    await writable.close();
                    document.getElementById('export-btn').textContent = "üíæ Save (Instant)";
                    
                    if (document.getElementById('autosave-toggle').checked) {
                        startAutoSave();
                    }
                    return;
                } catch(e) { if(e.name !== 'AbortError') alert("Save failed. Using download fallback."); }
            }
            exportNotes(); 
        }

        function startAutoSave() {
            if (autoSaveInterval) clearInterval(autoSaveInterval);
            autoSaveInterval = setInterval(() => {
                saveNotes(true);
            }, 120000); // 2 minutes
            console.log("Auto-save timer started");
        }

        function toggleAutoSave() {
            const isChecked = document.getElementById('autosave-toggle').checked;
            if (autoSaveInterval) { clearInterval(autoSaveInterval); autoSaveInterval = null; }
            if (isChecked) {
                if (fileHandle) {
                    startAutoSave();
                    alert("Auto-save started.");
                }
            }
        }

        function exportNotes() {
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(state));
            const downloadAnchorNode = document.createElement('a'); downloadAnchorNode.setAttribute("href", dataStr);
            const date = new Date().toISOString().slice(0,10); downloadAnchorNode.setAttribute("download", "lecture_notes_" + date + ".json");
            document.body.appendChild(downloadAnchorNode); downloadAnchorNode.click(); downloadAnchorNode.remove();
        }

        function loadImportedData(jsonString) {
            try {
                let imported = JSON.parse(jsonString);
                if (imported.memory && (!imported.slides || imported.slides.length === 0)) {
                    imported.slides = [];
                    const indices = Object.keys(imported.memory).map(Number).sort((a,b)=>a-b);
                    const maxIdx = indices.length > 0 ? indices[indices.length-1] : 0;
                    for(let i=0; i<=maxIdx; i++) {
                        const d = imported.memory[i] || {};
                        imported.slides.push({ type: 'pdf', pdfPage: i+1, header: d.header||"", notes: d.notes||"", drawings: d.drawings||[] });
                    }
                    if(imported.count !== undefined) imported.count++;
                }
                state = imported;
                if(state.count < 1) state.count = 1;
                historyStacks = {}; 
                updateDisplay();
                if(pdfDoc && MODES[currentModeIndex] === 'PDF') renderPage();
            } catch(err) { alert("Error reading JSON"); }
        }

        function clearAllData() { if(confirm("Reset all?")) { state = { count: 1, slides: [] }; location.reload(); } }

        function toggleMenu() { controlsPanel.classList.toggle('active'); if(controlsPanel.classList.contains('active')) setTimeout(()=>searchInput.focus(),100); }
        function updateNumberSize(val) { display.style.fontSize = val + "px"; }
        function updateTextSize(val) { editor.style.fontSize = val + "px"; preview.style.fontSize = val + "px"; slideLabel.style.fontSize = (val * 1.5) + "px"; }
        function updatePdfSize(val) { pdfContainer.style.height = val + "vh"; }
        function refreshPdfResolution() { if (MODES[currentModeIndex] === 'PDF' && pdfDoc) renderPage(); }
        function activateEditor() { isEditorActive = true; editor.style.display = 'block'; preview.style.display = 'none'; editor.focus(); }
        function activatePreview() { isEditorActive = false; editor.style.display = 'none'; preview.style.display = 'block'; updateDisplay(); }

        // ==========================================
        // 3. EVENT LISTENERS
        // ==========================================

        document.getElementById('pdf-upload').value = '';
        document.getElementById('json-upload').value = '';

        window.addEventListener('beforeunload', function (e) {
            if (checkIfDirty()) { e.preventDefault(); e.returnValue = ''; }
        });

        document.getElementById('pdf-upload').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file && file.type === "application/pdf") {
                const fileReader = new FileReader();
                fileReader.onload = function() {
                    const typedarray = new Uint8Array(this.result);
                    pdfjsLib.getDocument(typedarray).promise.then(function(pdfDoc_) {
                        pdfDoc = pdfDoc_;
                        noPdfMsg.style.display = "none";
                        if (state.slides.length <= 1 && !state.slides[0].notes && !state.slides[0].header) {
                            state.slides = [];
                            for(let i=1; i<=pdfDoc.numPages; i++) {
                                state.slides.push({ type:'pdf', pdfPage:i, header:"", notes:"", drawings:[] });
                            }
                            state.count = 1;
                            updateDisplay();
                        }
                        const pdfModeIdx = MODES.indexOf('PDF');
                        if (pdfModeIdx !== -1) { currentModeIndex = pdfModeIdx; updateUIForMode(); }
                        renderPage();
                        document.getElementById('pdf-upload').blur();
                    });
                };
                fileReader.readAsArrayBuffer(file);
            }
        });

        document.getElementById('json-upload').addEventListener('change', function(e) {
            const file = e.target.files[0]; if (!file) return;
            const reader = new FileReader();
            reader.onload = function(event) {
                loadImportedData(event.target.result);
            };
            reader.readAsText(file);
            e.target.value = '';
        });

        slideLabel.addEventListener('input', handleInput);
        editor.addEventListener('input', handleInput);
        
        // CLICK AWAY (BLUR) LISTENER
        editor.addEventListener('blur', function() {
            activatePreview();
        });

        editor.addEventListener('keydown', (e) => {
            const idx = state.count - 1;
            
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                e.preventDefault();
                activatePreview();
                return;
            }

            if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                e.preventDefault(); isRestoring = true;
                const restored = undo(idx);
                if (restored !== null && restored !== undefined) { editor.value = restored; state.slides[idx].notes = restored; }
                isRestoring = false; return;
            }
            if (((e.ctrlKey || e.metaKey) && e.key === 'y') || ((e.ctrlKey || e.metaKey) && e.key === 'z' && e.shiftKey)) {
                e.preventDefault(); isRestoring = true;
                const restored = redo(idx);
                if (restored !== null && restored !== undefined) { editor.value = restored; state.slides[idx].notes = restored; }
                isRestoring = false; return;
            }
            if (e.key === 'Tab') {
                e.preventDefault(); pushSnapshot(idx, editor.value);
                const start = editor.selectionStart; const end = editor.selectionEnd; const val = editor.value;
                const lineStart = val.lastIndexOf('\n', start - 1) + 1;
                if (e.shiftKey) {
                    const line = val.substring(lineStart);
                    const match = line.match(/^ {1,4}/);
                    if (match) {
                        const len = match[0].length;
                        editor.value = val.substring(0, lineStart) + val.substring(lineStart + len);
                        editor.selectionStart = Math.max(lineStart, start - len); editor.selectionEnd = Math.max(lineStart, end - len);
                    }
                } else {
                    editor.value = val.substring(0, lineStart) + "    " + val.substring(lineStart);
                    editor.selectionStart = start + 4; editor.selectionEnd = end + 4;
                }
                handleInput();
            }
            if (e.key === 'Backspace' || e.key === 'Delete' || (e.ctrlKey && e.key === 'x') || (e.ctrlKey && e.key === 'v')) {
                 pushSnapshot(idx, editor.value);
            }
            if (e.key === 'Enter') {
                pushSnapshot(idx, editor.value);
                const start = editor.selectionStart; const end = editor.selectionEnd; const val = editor.value;
                const lineStart = val.lastIndexOf('\n', start - 1) + 1;
                const match = val.substring(lineStart, start).match(/^(\s*)([-*]|\d+\.)\s/);
                if (match) {
                    e.preventDefault(); const indent = match[1]; const marker = match[2];
                    let nextMarker = marker;
                    if (/^\d+\.$/.test(marker)) { const num = parseInt(marker); nextMarker = (num + 1) + "."; }
                    const prefix = `\n${indent}${nextMarker} `;
                    const newVal = val.substring(0, start) + prefix + val.substring(end);
                    editor.value = newVal; editor.selectionStart = editor.selectionEnd = start + prefix.length; handleInput();
                }
            }
        });

        // --- MOUSE WHEEL NAVIGATION (NEW: 30ms throttle) ---
        let lastScrollTime = 0;
        document.addEventListener('wheel', (e) => {
            const notesDiv = document.getElementById('notes-wrapper');
            const sidebarDiv = document.getElementById('sidebar'); // FIXED SCROLL BUG
            
            if (notesDiv.contains(e.target) || sidebarDiv.contains(e.target)) return;

            const now = Date.now();
            // Throttling 30ms for faster scroll
            if (now - lastScrollTime < 30) return;

            if (e.deltaY > 0) {
                handleNav('forward');
                lastScrollTime = now;
            } else if (e.deltaY < 0) {
                handleNav('backward');
                lastScrollTime = now;
            }
        });

        drawCanvas.addEventListener('mousedown', (e) => {
            const norm = getNormalizedPos(e);
            if (currentTool === 'eraser') { isErasing = true; eraseStrokeAtInternal(toPixel(norm.x, norm.y)); } 
            else { isDrawing = true; currentStrokes.push({ points: [norm] }); const px = toPixel(norm.x, norm.y); drawCtx.lineWidth=3; drawCtx.strokeStyle='red'; drawCtx.lineCap='round'; drawCtx.beginPath(); drawCtx.moveTo(px.x, px.y); drawCtx.lineTo(px.x, px.y); drawCtx.stroke(); }
        });
        drawCanvas.addEventListener('mousemove', (e) => {
            const norm = getNormalizedPos(e); const px = toPixel(norm.x, norm.y);
            if (currentTool === 'eraser' && isErasing) { eraseStrokeAtInternal(px); return; }
            if (currentTool === 'pen' && isDrawing) {
                const path = currentStrokes[currentStrokes.length - 1];
                const last = path.points[path.points.length - 1]; const lastPx = toPixel(last.x, last.y);
                drawCtx.lineWidth=3; drawCtx.strokeStyle='red'; drawCtx.lineCap='round'; drawCtx.beginPath(); drawCtx.moveTo(lastPx.x, lastPx.y); drawCtx.lineTo(px.x, px.y); drawCtx.stroke();
                path.points.push(norm);
            }
        });
        drawCanvas.addEventListener('mouseup', endAction); drawCanvas.addEventListener('mouseout', endAction);

        searchInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); if(e.shiftKey) nextMatch(-1); else nextMatch(1); } });
        document.addEventListener('keydown', e => {
            if (e.key === 'Escape') { activatePreview(); if(document.activeElement === searchInput) { clearSearch(); toggleMenu(); } document.activeElement.blur(); return; }
            if ((e.ctrlKey || e.metaKey) && e.key === 'f') { e.preventDefault(); if(!controlsPanel.classList.contains('active')) toggleMenu(); searchInput.focus(); return; }
            if (e.ctrlKey || e.metaKey) {
                if (e.key === 'ArrowUp' || e.key === 'ArrowRight') { e.preventDefault(); handleNav('forward'); return; }
                if (e.key === 'ArrowDown' || e.key === 'ArrowLeft') { e.preventDefault(); handleNav('backward'); return; }
            }
            if (document.activeElement === editor || document.activeElement === searchInput) return;
            
            // FIXED HEADER TYPING BUG
            if (document.activeElement === slideLabel) {
                 if (['ArrowUp','ArrowDown'].includes(e.key)) { e.preventDefault(); handleNav(e.key === 'ArrowUp' ? 'forward' : 'backward'); } 
                 // ADDED MISSING HEADER ENTER BEHAVIOR
                 if (e.key === 'Enter') { e.preventDefault(); document.activeElement.blur(); }
                 return; 
            }

            // NEW: 'i' Key for Dark Mode
            if (e.key === 'i' && !isEditorActive) {
                pdfCanvas.classList.toggle('inverted');
                if (state.slides[state.count-1].type === 'blank') renderPage();
                return;
            }
            
            if(e.key === 'ArrowUp' || e.key === 'ArrowRight') handleNav('forward');
            else if(e.key === 'ArrowDown' || e.key === 'ArrowLeft') handleNav('backward');
        });

        // Initialize (Run once at start)
        updateUIForMode();
        updateDisplay();

    </script>
</body>
</html>