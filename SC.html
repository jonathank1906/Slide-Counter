<!DOCTYPE html>
<html>
<head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/9.1.6/marked.min.js"></script>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js"></script>

    <style>
        /* --- LAYOUT RESET --- */
        * { box-sizing: border-box; }

        body {
            margin: 0;
            height: 100vh; 
            font-family: Arial, sans-serif;
            background-color: black;
            color: white;
            overflow: hidden; 
            display: flex;
            flex-direction: column; 
        }

        /* --- 1. THE FIXED HEADER --- */
        #sticky-header-group {
            flex: 0 0 auto; 
            background: #000;
            border-bottom: 1px solid #222;
            padding: 10px 20px;
            z-index: 50;
            position: relative; 
            display: flex;
            flex-direction: column;
            justify-content: center; 
            align-items: center;
            min-height: 100px; 
        }

        #display {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%); 
            font-size: 80px; 
            font-weight: bold;
            user-select: none;
            line-height: 1;
            white-space: nowrap; 
            text-align: right;
            z-index: 20;
            text-shadow: 0 0 5px black;
        }

        #slideLabel {
            background: transparent;
            border-bottom: 1px solid #333; 
            color: #ddd;
            font-size: 30px; 
            outline: none;
            padding-bottom: 2px;
            margin-bottom: 10px;
            min-width: 200px;
            max-width: 60%; 
            text-align: center; 
            transition: border-color 0.2s;
            cursor: text;
            display: block; 
        }
        #slideLabel:focus { border-bottom: 1px solid #fff; }

        /* --- PDF & DRAWING --- */
        #pdf-render-container {
            display: none; 
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 30vh; 
            position: relative; 
            transition: height 0.1s ease; 
        }

        #the-canvas {
            max-height: 100%; 
            max-width: 80%;
            border: 1px solid #333;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            position: absolute; 
            z-index: 1;
        }

        #draw-canvas {
            max-height: 100%; 
            max-width: 80%;
            position: absolute; 
            z-index: 2; 
            touch-action: none; 
            pointer-events: none; 
        }
        
        #draw-canvas.active {
            pointer-events: auto; 
            border: 1px dashed rgba(255, 255, 255, 0.2); 
        }

        #no-pdf-msg { color: #444; font-style: italic; position: absolute; font-size: 14px; z-index: 0; }

        /* --- 2. NOTES AREA --- */
        #notes-container {
            flex: 1; 
            position: relative;
            overflow: hidden; 
            display: flex;
            justify-content: center; 
            border-top: 1px solid #111;
            background: #050505;
        }

        #notes-wrapper {
            width: 100%;
            max-width: 800px;
            height: 100%;
            padding: 20px;
            overflow-y: auto;
            position: relative;
        }
        
        #notes-wrapper::-webkit-scrollbar { width: 10px; }
        #notes-wrapper::-webkit-scrollbar-track { background: #111; }
        #notes-wrapper::-webkit-scrollbar-thumb { background: #333; border-radius: 5px; }

        /* The Editor */
        #slideNotesEditor {
            width: 100%;
            min-height: 100%;
            background: transparent;
            border: none;
            color: #aaa; 
            font-size: 18px; 
            text-align: left; 
            outline: none;
            font-family: 'Consolas', 'Courier New', monospace; 
            resize: none;
            line-height: 1.6;
            display: none; 
            tab-size: 4; 
        }

        /* The Preview */
        #slideNotesPreview {
            width: 100%;
            min-height: 100%;
            color: #ddd;
            font-size: 18px;
            line-height: 1.6;
            display: block;
            cursor: text; 
        }

        /* MARKDOWN STYLES */
        #slideNotesPreview h1, #slideNotesPreview h2, #slideNotesPreview h3 { color: #fff; margin-top: 20px; border-bottom: 1px solid #333; padding-bottom: 5px; }
        #slideNotesPreview ul, #slideNotesPreview ol { padding-left: 25px; margin-bottom: 10px; }
        #slideNotesPreview p { margin-bottom: 10px; }
        #slideNotesPreview blockquote { border-left: 4px solid #4CAF50; margin: 10px 0; padding-left: 15px; color: #aaa; font-style: italic; background: #111; padding: 5px;}
        #slideNotesPreview a { color: #58a6ff; text-decoration: none; }
        mark { background-color: #ffeb3b; color: black; border-radius: 2px; padding: 0 2px; font-weight: bold; }
        
        /* Code Blocks */
        #slideNotesPreview pre {
            background: #1e1e1e !important;
            padding: 10px;
            border-radius: 6px;
            overflow-x: auto;
            border: 1px solid #333;
            margin: 10px 0;
        }
        #slideNotesPreview code { font-family: 'Consolas', 'Courier New', monospace; font-size: 15px; }
        #slideNotesPreview :not(pre) > code { background: #2d2d2d; padding: 2px 5px; border-radius: 4px; color: #d19a66; border: 1px solid #444; }

        /* Tables */
        #slideNotesPreview table { border-collapse: collapse; width: 100%; margin: 15px 0; font-size: 16px; border: 1px solid #444; }
        #slideNotesPreview th, #slideNotesPreview td { border: 1px solid #444; padding: 8px 12px; text-align: left; }
        #slideNotesPreview th { background-color: #222; color: #fff; font-weight: bold; }
        #slideNotesPreview tr:nth-child(even) { background-color: #111; }
        #slideNotesPreview tr:nth-child(odd) { background-color: #161616; }

        #notes-mode-toggle {
            position: absolute; top: 10px; right: 20px; z-index: 100;
            background: transparent; border: 1px solid #333; color: #555; cursor: pointer; padding: 4px 8px; border-radius: 4px; font-size: 12px; opacity: 0.3; transition: opacity 0.2s;
        }
        #notes-mode-toggle:hover { opacity: 1; color: #fff; border-color: #666; }

        /* --- SETTINGS --- */
        #menu-container { position: absolute; top: 10px; left: 10px; z-index: 100; }
        #gear-btn { background: transparent; color: #555; border: none; font-size: 24px; cursor: pointer; padding: 5px; transition: color 0.2s; }
        #gear-btn:hover { color: #fff; }

        #controls-panel {
            display: none; margin-top: 5px; background: #111; padding: 15px;
            border-radius: 8px; border: 1px solid #333; flex-direction: column; gap: 15px; width: 300px; 
        }
        #controls-panel.active { display: flex; }

        button.action-btn { padding: 8px; font-size: 12px; cursor: pointer; background: #000; color: #ddd; border: 1px solid #444; border-radius: 4px; }
        button.action-btn:hover { background: #222; }
        
        .toolbar { display: flex; gap: 5px; background: #222; padding: 5px; border-radius: 5px; }
        .tool-btn { flex: 1; padding: 5px; font-size: 11px; cursor: pointer; background: #111; color: #888; border: 1px solid #444; border-radius: 3px; }
        .tool-btn.active { background: #444; color: #fff; border-color: #666; font-weight: bold; }

        #export-btn { border-color: #4CAF50; color: #4CAF50; }
        #export-btn:hover { background: #1b331c; }

        /* SEARCH STYLES */
        .search-group { display: flex; gap: 5px; align-items: center; }
        #search-input { flex: 1; background: #000; border: 1px solid #444; color: white; padding: 6px; font-size: 12px; border-radius: 4px; outline: none; }
        #search-input:focus { border-color: #4CAF50; }
        .search-nav-btn { background: #222; border: 1px solid #444; color: #aaa; cursor: pointer; padding: 6px 10px; border-radius: 4px; font-size: 12px; }
        .search-nav-btn:hover { background: #333; color: white; }
        #search-count { font-size: 10px; color: #666; min-width: 40px; text-align: center; }
        #clear-search-btn { background: transparent; border: none; color: #666; cursor: pointer; font-size: 14px; padding: 0 5px; }
        #clear-search-btn:hover { color: #ff4444; }

        /* SLIDE MANAGER STYLES */
        .slide-ops { display: flex; gap: 5px; }
        .slide-ops button { flex:1; padding: 6px; font-size: 10px; cursor: pointer; border: 1px solid #444; background: #111; color: #ccc; border-radius: 3px; }
        .slide-ops button:hover { background: #333; color: white; }
        .del-btn { color: #ff6666 !important; border-color: #552222 !important; }
        .del-btn:hover { background: #330000 !important; }

        .control-group { display: flex; flex-direction: column; gap: 5px; }
        label { font-size: 12px; color: #888; }
        input[type=range] { width: 100%; cursor: pointer; accent-color: #888; }
        input[type=file] { font-size: 12px; color: #aaa; }
        #mode-status { color: #aaa; font-size: 12px; font-weight: bold; }
        #clear-data-btn { color: #ff4444; border-color: #552222; }
        .empty-placeholder { color: #444; font-style: italic; }

    </style>
</head>
<body>

    <div id="menu-container">
        <button id="gear-btn" onclick="toggleMenu()">‚öô</button>
        <div id="controls-panel">
            
            <div class="control-group">
                <div id="mode-status">Mode: Standard</div>
                <button class="action-btn" onclick="cycleMode()">Switch Mode</button>
            </div>

            <div class="control-group">
                <label style="color:#aaa;">Slide Manager</label>
                <div class="slide-ops">
                    <button onclick="insertSlide(-1)">+ Blank Before</button>
                    <button onclick="insertSlide(1)">+ Blank After</button>
                </div>
                <div class="slide-ops">
                    <button class="del-btn" onclick="deleteCurrentSlide()">Delete Current</button>
                </div>
            </div>

            <div class="control-group">
                <label style="color:#4CAF50;">Search (Ctrl+F)</label>
                <div class="search-group">
                    <input type="text" id="search-input" placeholder="Find..." oninput="performSearch()">
                    <button id="clear-search-btn" title="Clear Search" onclick="clearSearch()">‚úñ</button>
                    <div id="search-count">0/0</div>
                </div>
                <div class="search-group">
                    <button class="search-nav-btn" style="flex:1" onclick="nextMatch(-1)">Prev</button>
                    <button class="search-nav-btn" style="flex:1" onclick="nextMatch(1)">Next</button>
                </div>
            </div>
            
            <div class="control-group" id="drawing-controls" style="display:none;">
                <label>Drawing Tools</label>
                <div class="toolbar">
                    <button class="tool-btn active" id="btn-pen" onclick="setTool('pen')">Pen</button>
                    <button class="tool-btn" id="btn-eraser" onclick="setTool('eraser')">Stroke Eraser</button>
                    <button class="tool-btn" style="color:#ff6666;" onclick="clearSlideDrawing()">Clear Slide</button>
                </div>
            </div>
            
            <hr style="width:100%; border:0; border-top:1px solid #333;">
            <div class="control-group"><label style="color:cyan;">1. Load Slides (PDF)</label><input type="file" id="pdf-upload" accept=".pdf"></div>
            <div class="control-group"><label style="color:orange;">2. Import Notes (JSON)</label><input type="file" id="json-upload" accept=".json"></div>
            <div class="control-group"><button id="export-btn" class="action-btn" onclick="exportNotes()">3. Save/Export Notes</button></div>
            <hr style="width:100%; border:0; border-top:1px solid #333;">
            <div class="control-group"><label>Number Size</label><input type="range" min="20" max="120" value="80" oninput="updateNumberSize(this.value)"></div>
            <div class="control-group"><label>Text Size</label><input type="range" min="12" max="60" value="18" oninput="updateTextSize(this.value)"></div>
            <div class="control-group"><label>PDF Preview Size</label><input type="range" min="10" max="60" value="30" oninput="updatePdfSize(this.value)" onchange="refreshPdfResolution()"></div>
            <button id="clear-data-btn" class="action-btn" onclick="clearAllData()">Reset All</button>
        </div>
    </div>

    <div id="sticky-header-group">
        <div id="display">1</div>
        <span id="slideLabel" contenteditable="true" role="textbox" data-placeholder="Header..."></span>
        
        <div id="pdf-render-container">
            <div id="no-pdf-msg">Load PDF in Settings (‚öô)</div>
            <canvas id="the-canvas"></canvas>
            <canvas id="draw-canvas"></canvas>
        </div>
    </div>

    <div id="notes-container">
        <button id="notes-mode-toggle" title="Toggle Edit/Preview" onclick="toggleNotesModeManual()">üëÅÔ∏è</button>
        <div id="notes-wrapper">
            <textarea id="slideNotesEditor" placeholder="Type Markdown here... (Math: $x^2$, Code: ```js ...)"></textarea>
            <div id="slideNotesPreview" onclick="activateEditor()"></div>
        </div>
    </div>

    <script>
        // --- CONFIGURE LIBRARIES ---
        marked.setOptions({
            highlight: function(code, lang) {
                if (lang && hljs.getLanguage(lang)) { return hljs.highlight(code, { language: lang }).value; }
                return hljs.highlightAuto(code).value;
            },
            langPrefix: 'hljs language-'
        });

        // --- STATE ---
        const savedData = localStorage.getItem('slideTrackerData_Final_SmartLists'); 
        let state = savedData ? JSON.parse(savedData) : { count: 1, slides: [] };

        // MIGRATION
        if (state.memory && (!state.slides || state.slides.length === 0)) {
            state.slides = [];
            const indices = Object.keys(state.memory).map(Number).sort((a,b)=>a-b);
            const maxIdx = indices.length > 0 ? indices[indices.length-1] : 0;
            for(let i=0; i<=maxIdx; i++) {
                const d = state.memory[i] || {};
                state.slides.push({ type: 'pdf', pdfPage: i+1, header: d.header||"", notes: d.notes||"", drawings: d.drawings||[] });
            }
            delete state.memory;
        }
        
        if (!state.slides || state.slides.length === 0) {
            state.slides = [{ type: 'blank', header: '', notes: '', drawings: [] }];
            state.count = 1;
        }
        if(state.count < 1) state.count = 1;

        const MODES = ['NUM', 'PULSE', 'PDF'];
        let currentModeIndex = 0; 
        let pdfDoc = null;
        let renderTask = null;

        const pdfCanvas = document.getElementById('the-canvas');
        const drawCanvas = document.getElementById('draw-canvas');
        const pdfCtx = pdfCanvas.getContext('2d');
        const drawCtx = drawCanvas.getContext('2d');
        const display = document.getElementById('display');
        const slideLabel = document.getElementById('slideLabel');
        const editor = document.getElementById('slideNotesEditor');
        const preview = document.getElementById('slideNotesPreview');
        const toggleBtn = document.getElementById('notes-mode-toggle');
        const pdfContainer = document.getElementById('pdf-render-container');
        const noPdfMsg = document.getElementById('no-pdf-msg');
        const modeStatus = document.getElementById('mode-status');
        const controlsPanel = document.getElementById('controls-panel');
        const drawingControls = document.getElementById('drawing-controls');
        const btnPen = document.getElementById('btn-pen');
        const btnEraser = document.getElementById('btn-eraser');
        
        // SEARCH
        const searchInput = document.getElementById('search-input');
        const searchCount = document.getElementById('search-count');
        let searchMatches = []; 
        let currentMatchPos = -1;

        let timeoutHandle = null;
        let isEditorActive = false;

        // Init
        updateUIForMode();
        updateDisplay();

        function saveData() {
            localStorage.setItem('slideTrackerData_Final_SmartLists', JSON.stringify(state));
        }

        // --- SLIDE MANAGER ---
        function insertSlide(offset) {
            handleInput();
            const newSlide = { type: 'blank', header: '', notes: '', drawings: [] };
            let insertIndex = (offset === 1) ? state.count : state.count - 1;
            state.slides.splice(insertIndex, 0, newSlide);
            if (offset === 1) state.count++; 
            saveData();
            updateDisplay();
            if (MODES[currentModeIndex] === 'PDF') renderPage();
        }

        function deleteCurrentSlide() {
            if (state.slides.length <= 1) { alert("Cannot delete the only slide."); return; }
            if (!confirm("Delete current slide?")) return;
            const idx = state.count - 1;
            state.slides.splice(idx, 1);
            if (state.count > state.slides.length) state.count = state.slides.length;
            saveData();
            updateDisplay();
            if (MODES[currentModeIndex] === 'PDF') renderPage();
        }

        // --- SEARCH LOGIC ---
        function performSearch() {
            const query = searchInput.value.toLowerCase().trim();
            searchMatches = [];
            currentMatchPos = -1;
            if (query.length === 0) { searchCount.textContent = "0/0"; updateDisplay(); return; }
            handleInput();
            state.slides.forEach((slide, index) => {
                const header = (slide.header || "").toLowerCase();
                const notes = (slide.notes || "").toLowerCase();
                if (header.includes(query) || notes.includes(query)) { searchMatches.push(index + 1); }
            });
            if (searchMatches.length > 0) {
                const upcoming = searchMatches.findIndex(num => num >= state.count);
                currentMatchPos = (upcoming !== -1) ? upcoming : 0;
                searchCount.textContent = `${currentMatchPos + 1}/${searchMatches.length}`;
            } else { searchCount.textContent = "0/0"; }
            updateDisplay();
        }

        function nextMatch(dir) {
            if (searchMatches.length === 0) return;
            if (state.count === searchMatches[currentMatchPos]) currentMatchPos += dir;
            if (currentMatchPos >= searchMatches.length) currentMatchPos = 0;
            if (currentMatchPos < 0) currentMatchPos = searchMatches.length - 1;
            searchCount.textContent = `${currentMatchPos + 1}/${searchMatches.length}`;
            state.count = searchMatches[currentMatchPos];
            saveData();
            updateDisplay();
            activatePreview(); 
            if (MODES[currentModeIndex] === 'PDF') renderPage();
        }
        function clearSearch() { searchInput.value = ""; performSearch(); searchInput.blur(); }

        // --- NOTES LOGIC ---
        function activateEditor() {
            isEditorActive = true;
            editor.style.display = 'block'; preview.style.display = 'none'; toggleBtn.textContent = '‚úèÔ∏è'; editor.focus();
        }
        function activatePreview() {
            isEditorActive = false;
            editor.style.display = 'none'; preview.style.display = 'block'; toggleBtn.textContent = 'üëÅÔ∏è'; updateDisplay();
        }
        function toggleNotesModeManual() { if(isEditorActive) activatePreview(); else activateEditor(); }
        editor.addEventListener('blur', (e) => { setTimeout(() => { if (document.activeElement !== toggleBtn) activatePreview(); }, 100); });
        
        // --- SMART EDITOR KEYS (TAB & ENTER) ---
        editor.addEventListener('keydown', (e) => {
            // 1. TAB INDENT / UN-INDENT
            if (e.key === 'Tab') {
                e.preventDefault();
                const start = editor.selectionStart;
                const end = editor.selectionEnd;
                const value = editor.value;
                const lineStart = value.lastIndexOf('\n', start - 1) + 1;
                
                if (e.shiftKey) {
                    // Outdent (Shift+Tab): Remove up to 4 spaces at line start
                    const currentLine = value.substring(lineStart);
                    const match = currentLine.match(/^ {1,4}/);
                    if (match) {
                        const removeLen = match[0].length;
                        editor.value = value.substring(0, lineStart) + value.substring(lineStart + removeLen);
                        editor.selectionStart = Math.max(lineStart, start - removeLen);
                        editor.selectionEnd = Math.max(lineStart, end - removeLen);
                    }
                } else {
                    // Indent (Tab): Insert 4 spaces at line start
                    editor.value = value.substring(0, lineStart) + "    " + value.substring(lineStart);
                    editor.selectionStart = start + 4;
                    editor.selectionEnd = end + 4;
                }
                handleInput();
            }
            
            // 2. AUTO-LIST ON ENTER
            if (e.key === 'Enter') {
                const start = editor.selectionStart;
                const end = editor.selectionEnd;
                const val = editor.value;
                const lineStart = val.lastIndexOf('\n', start - 1) + 1;
                const currentLine = val.substring(lineStart, start);
                
                const match = currentLine.match(/^(\s*)([-*]|\d+\.)\s/);
                
                if (match) {
                    e.preventDefault();
                    const indent = match[1];
                    const marker = match[2];
                    
                    let nextMarker = marker;
                    // Increment numbers
                    if (/^\d+\.$/.test(marker)) {
                        const num = parseInt(marker);
                        nextMarker = (num + 1) + ".";
                    }
                    
                    const prefix = `\n${indent}${nextMarker} `;
                    const newVal = val.substring(0, start) + prefix + val.substring(end);
                    
                    editor.value = newVal;
                    editor.selectionStart = editor.selectionEnd = start + prefix.length;
                    handleInput();
                }
            }
        });

        // --- DRAWING LOGIC ---
        let isDrawing = false; let isErasing = false; let currentTool = 'pen'; let currentStrokes = []; 
        function setTool(tool) {
            currentTool = tool;
            if(tool === 'pen') { btnPen.classList.add('active'); btnEraser.classList.remove('active'); drawCanvas.style.cursor = 'crosshair'; } 
            else { btnPen.classList.remove('active'); btnEraser.classList.add('active'); drawCanvas.style.cursor = 'cell'; }
        }
        function clearSlideDrawing() {
            if(confirm("Clear drawings?")) {
                const s = state.slides[state.count - 1];
                if (s) { s.drawings = []; saveData(); renderDrawings(); }
            }
        }
        function toNorm(x, y) { return { x: x / drawCanvas.width, y: y / drawCanvas.height }; }
        function toPixel(xNorm, yNorm) { return { x: xNorm * drawCanvas.width, y: yNorm * drawCanvas.height }; }
        function getNormalizedPos(e) {
            const rect = drawCanvas.getBoundingClientRect();
            return { x: (e.clientX - rect.left) / rect.width, y: (e.clientY - rect.top) / rect.height };
        }
        drawCanvas.addEventListener('mousedown', (e) => {
            const norm = getNormalizedPos(e);
            if (currentTool === 'eraser') { isErasing = true; eraseStrokeAtInternal(toPixel(norm.x, norm.y)); } 
            else { isDrawing = true; currentStrokes.push({ points: [norm] }); const px = toPixel(norm.x, norm.y); drawCtx.lineWidth=3; drawCtx.strokeStyle='red'; drawCtx.lineCap='round'; drawCtx.beginPath(); drawCtx.moveTo(px.x, px.y); drawCtx.lineTo(px.x, px.y); drawCtx.stroke(); }
        });
        drawCanvas.addEventListener('mousemove', (e) => {
            const norm = getNormalizedPos(e); const px = toPixel(norm.x, norm.y);
            if (currentTool === 'eraser' && isErasing) { eraseStrokeAtInternal(px); return; }
            if (currentTool === 'pen' && isDrawing) {
                const path = currentStrokes[currentStrokes.length - 1];
                const last = path.points[path.points.length - 1]; const lastPx = toPixel(last.x, last.y);
                drawCtx.lineWidth=3; drawCtx.strokeStyle='red'; drawCtx.lineCap='round'; drawCtx.beginPath(); drawCtx.moveTo(lastPx.x, lastPx.y); drawCtx.lineTo(px.x, px.y); drawCtx.stroke();
                path.points.push(norm);
            }
        });
        drawCanvas.addEventListener('mouseup', endAction); drawCanvas.addEventListener('mouseout', endAction);
        function endAction() { if(isDrawing) { isDrawing = false; saveDrawingsToState(); } if(isErasing) isErasing = false; }
        
        function eraseStrokeAtInternal(pos) {
            const slide = state.slides[state.count - 1];
            const drawings = slide ? (slide.drawings || []) : [];
            if(drawings.length === 0) return;
            const remaining = drawings.filter(path => {
                return !path.points.some(pt => {
                    const pPx = toPixel(pt.x, pt.y);
                    return Math.hypot(pPx.x - pos.x, pPx.y - pos.y) < 25;
                });
            });
            if(remaining.length !== drawings.length) { slide.drawings = remaining; saveData(); renderDrawings(); }
        }
        function saveDrawingsToState() {
            const slide = state.slides[state.count - 1];
            if(slide) {
                if(!slide.drawings) slide.drawings = [];
                slide.drawings = slide.drawings.concat(currentStrokes);
                currentStrokes = []; saveData();
            }
        }
        function renderDrawings() {
            drawCtx.clearRect(0,0,drawCanvas.width,drawCanvas.height);
            const slide = state.slides[state.count - 1];
            const drawings = slide ? (slide.drawings || []) : [];
            drawings.forEach(path => {
                drawCtx.strokeStyle='red'; drawCtx.lineWidth=3; drawCtx.lineCap='round'; drawCtx.lineJoin='round'; if(path.points.length<1) return;
                drawCtx.beginPath(); const start = toPixel(path.points[0].x, path.points[0].y); drawCtx.moveTo(start.x, start.y);
                for(let i=1; i<path.points.length; i++) { const p = toPixel(path.points[i].x, path.points[i].y); drawCtx.lineTo(p.x, p.y); } drawCtx.stroke();
            });
        }
        function resizeDrawLayer() { drawCanvas.width = pdfCanvas.width; drawCanvas.height = pdfCanvas.height; renderDrawings(); }

        // --- APP LOGIC ---
        function handleInput() {
            const idx = state.count - 1;
            if(!state.slides[idx]) state.slides[idx] = { type:'blank', drawings:[] };
            state.slides[idx].header = slideLabel.innerText;
            state.slides[idx].notes = editor.value; 
            saveData();
        }
        slideLabel.addEventListener('input', handleInput);
        editor.addEventListener('input', handleInput);

        function handleNav(direction) {
            const mode = MODES[currentModeIndex];
            if(isEditorActive) activatePreview();
            
            if (direction === 'forward') {
                if (state.count === state.slides.length) {
                    let nextType = 'blank';
                    let nextPdfPage = null;
                    if (pdfDoc) {
                        let lastPage = 0;
                        for(let i = state.slides.length - 1; i >= 0; i--) {
                            if(state.slides[i].type === 'pdf') { lastPage = state.slides[i].pdfPage; break; }
                        }
                        if(lastPage < pdfDoc.numPages) { nextType='pdf'; nextPdfPage = lastPage+1; }
                    }
                    state.slides.push({ type: nextType, pdfPage: nextPdfPage, header: "", notes: "", drawings: [] });
                }
                state.count++;
                if (mode === 'PULSE') triggerFlash(">>>");
            } 
            else if (direction === 'backward') { 
                if (state.count > 1) { 
                    state.count--; 
                    if (mode === 'PULSE') triggerFlash("<<<"); 
                } 
            }
            saveData(); updateDisplay();
            if (mode === 'PDF') renderPage();
        }

        function updateDisplay() {
            const mode = MODES[currentModeIndex];
            const slide = state.slides[state.count - 1] || { type:'blank', header:'', notes:'' };

            slideLabel.innerText = slide.header || "";
            const noteContent = slide.notes || "";
            editor.value = noteContent;
            
            let htmlContent = "";
            if (typeof marked !== 'undefined') htmlContent = noteContent.trim() ? marked.parse(noteContent) : '<span class="empty-placeholder">Click to add notes...</span>';
            else htmlContent = noteContent;

            const searchTerm = searchInput.value.trim();
            if (searchTerm.length > 0) {
                const regex = new RegExp(`(${searchTerm})`, 'gi');
                htmlContent = htmlContent.replace(regex, '<mark>$1</mark>');
            }
            preview.innerHTML = htmlContent;

            // Render Math (KaTeX)
            if (typeof renderMathInElement !== 'undefined') {
                renderMathInElement(preview, {
                    delimiters: [
                        {left: '$$', right: '$$', display: true},
                        {left: '$', right: '$', display: false}
                    ],
                    throwOnError: false
                });
            }

            if (mode === 'NUM' || mode === 'PDF') { display.textContent = state.count; display.style.color = "white"; } 
            else if (mode === 'PULSE') { if (!timeoutHandle) { display.textContent = "---"; display.style.color = "#333"; } }
        }

        function triggerFlash(symbol) {
            if (timeoutHandle) clearTimeout(timeoutHandle);
            display.textContent = symbol; display.style.color = "white"; 
            timeoutHandle = setTimeout(() => { display.textContent = "---"; display.style.color = "#333"; timeoutHandle = null; }, 500);
        }

        function cycleMode() {
            currentModeIndex = (currentModeIndex + 1) % MODES.length;
            updateUIForMode();
            if (MODES[currentModeIndex] === 'PDF') renderPage();
        }

        function updateUIForMode() {
            const mode = MODES[currentModeIndex];
            if (mode === 'PDF') {
                slideLabel.style.display = 'block'; pdfContainer.style.display = 'flex'; modeStatus.textContent = "Mode: PDF Slides";
                drawCanvas.classList.add('active'); drawingControls.style.display = 'flex'; setTool('pen'); 
            } else {
                slideLabel.style.display = 'block'; pdfContainer.style.display = 'none'; modeStatus.textContent = (mode === 'NUM') ? "Mode: Standard" : "Mode: No Numbers";
                drawCanvas.classList.remove('active'); drawingControls.style.display = 'none';
            }
            if(timeoutHandle) { clearTimeout(timeoutHandle); timeoutHandle = null; }
            updateDisplay(); 
        }

        // --- PDF ENGINE ---
        document.getElementById('pdf-upload').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file && file.type === "application/pdf") {
                const fileReader = new FileReader();
                fileReader.onload = function() {
                    const typedarray = new Uint8Array(this.result);
                    pdfjsLib.getDocument(typedarray).promise.then(function(pdfDoc_) {
                        pdfDoc = pdfDoc_;
                        noPdfMsg.style.display = "none";
                        if (state.slides.length <= 1 && !state.slides[0].notes && !state.slides[0].header) {
                            state.slides = [];
                            for(let i=1; i<=pdfDoc.numPages; i++) {
                                state.slides.push({ type:'pdf', pdfPage:i, drawings:[] });
                            }
                            state.count = 1;
                            saveData();
                            updateDisplay();
                        }
                        if (MODES[currentModeIndex] === 'PDF') renderPage();
                    });
                };
                fileReader.readAsArrayBuffer(file);
            }
        });

        function renderPage() {
            if (renderTask) renderTask.cancel();
            const slide = state.slides[state.count - 1];
            if (!slide || slide.type === 'blank') {
                pdfCtx.clearRect(0,0,pdfCanvas.width,pdfCanvas.height);
                if(pdfCanvas.width < 100) { pdfCanvas.width=800; pdfCanvas.height=450; } 
                resizeDrawLayer();
                return;
            }
            if (!pdfDoc) return;
            const pageNum = slide.pdfPage || state.count;
            if(pageNum > pdfDoc.numPages) { pdfCtx.clearRect(0,0,pdfCanvas.width,pdfCanvas.height); return; }

            pdfDoc.getPage(pageNum).then(function(page) {
                const containerHeight = pdfContainer.clientHeight;
                const unscaledViewport = page.getViewport({scale: 1});
                const scale = containerHeight / unscaledViewport.height;
                const viewport = page.getViewport({scale: scale});
                pdfCanvas.height = viewport.height; pdfCanvas.width = viewport.width;
                resizeDrawLayer();
                const renderContext = { canvasContext: pdfCtx, viewport: viewport };
                renderTask = page.render(renderContext);
                renderTask.promise.then(() => { renderTask = null; }).catch((err) => { if(err.name !== 'RenderingCancelledException') console.log(err); });
            });
        }

        // --- JSON EXPORT ---
        function exportNotes() {
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(state));
            const downloadAnchorNode = document.createElement('a'); downloadAnchorNode.setAttribute("href", dataStr);
            const date = new Date().toISOString().slice(0,10); downloadAnchorNode.setAttribute("download", "lecture_notes_" + date + ".json");
            document.body.appendChild(downloadAnchorNode); downloadAnchorNode.click(); downloadAnchorNode.remove();
        }
        document.getElementById('json-upload').addEventListener('change', function(e) {
            const file = e.target.files[0]; if (!file) return;
            const reader = new FileReader();
            reader.onload = function(event) {
                try {
                    let imported = JSON.parse(event.target.result);
                    if (imported.memory && (!imported.slides || imported.slides.length === 0)) {
                        imported.slides = [];
                        const indices = Object.keys(imported.memory).map(Number).sort((a,b)=>a-b);
                        const maxIdx = indices.length > 0 ? indices[indices.length-1] : 0;
                        for(let i=0; i<=maxIdx; i++) {
                            const d = imported.memory[i] || {};
                            imported.slides.push({ type: 'pdf', pdfPage: i+1, header: d.header||"", notes: d.notes||"", drawings: d.drawings||[] });
                        }
                        delete imported.memory;
                        if(imported.count !== undefined) imported.count++;
                    }
                    state = imported;
                    if(state.count < 1) state.count = 1;
                    saveData(); updateDisplay();
                    if(pdfDoc && MODES[currentModeIndex] === 'PDF') renderPage();
                    alert("Notes loaded!");
                } catch(err) { alert("Error reading JSON"); }
            };
            reader.readAsText(file);
        });

        // --- UTILS ---
        function toggleMenu() { controlsPanel.classList.toggle('active'); if(controlsPanel.classList.contains('active')) setTimeout(()=>searchInput.focus(),100); }
        function updateNumberSize(val) { display.style.fontSize = val + "px"; }
        function updateTextSize(val) { editor.style.fontSize = val + "px"; preview.style.fontSize = val + "px"; slideLabel.style.fontSize = (val * 1.5) + "px"; }
        function updatePdfSize(val) { pdfContainer.style.height = val + "vh"; }
        function refreshPdfResolution() { if (MODES[currentModeIndex] === 'PDF' && pdfDoc) renderPage(); }
        function clearAllData() { if(confirm("Reset all?")) { state = { count: 1, slides: [] }; saveData(); location.reload(); } }

        // --- KEYS ---
        searchInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); if(e.shiftKey) nextMatch(-1); else nextMatch(1); } });

        document.addEventListener('keydown', e => {
            if (e.key === 'Escape') { activatePreview(); if(document.activeElement === searchInput) { clearSearch(); toggleMenu(); } document.activeElement.blur(); return; }
            if ((e.ctrlKey || e.metaKey) && e.key === 'f') { e.preventDefault(); if(!controlsPanel.classList.contains('active')) toggleMenu(); searchInput.focus(); return; }
            if (e.ctrlKey || e.metaKey) {
                if (e.key === 'ArrowUp' || e.key === 'ArrowRight') { e.preventDefault(); handleNav('forward'); return; }
                if (e.key === 'ArrowDown' || e.key === 'ArrowLeft') { e.preventDefault(); handleNav('backward'); return; }
            }
            if (document.activeElement === editor || document.activeElement === searchInput) return;
            if (document.activeElement === slideLabel) {
                 if (['ArrowUp','ArrowDown'].includes(e.key)) { e.preventDefault(); handleNav(e.key === 'ArrowUp' ? 'forward' : 'backward'); } return;
            }
            if(e.key === 'ArrowUp' || e.key === 'ArrowRight') handleNav('forward');
            else if(e.key === 'ArrowDown' || e.key === 'ArrowLeft') handleNav('backward');
        });
    </script>
</body>
</html>