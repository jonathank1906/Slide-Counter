<!DOCTYPE html>
<html>
<head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/9.1.6/marked.min.js"></script>

    <style>
        /* --- LAYOUT RESET --- */
        * { box-sizing: border-box; }

        body {
            margin: 0;
            height: 100vh; 
            font-family: Arial, sans-serif;
            background-color: black;
            color: white;
            overflow: hidden; 
            display: flex;
            flex-direction: column; 
        }

        /* --- 1. THE FIXED HEADER --- */
        #sticky-header-group {
            flex: 0 0 auto; 
            background: #000;
            border-bottom: 1px solid #222;
            padding: 10px 20px;
            z-index: 50;
            position: relative; 
            display: flex;
            justify-content: center; 
            align-items: center;
            min-height: 100px; 
        }

        /* Number/Arrow in Top Right */
        #display {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%); 
            font-size: 80px; 
            font-weight: bold;
            user-select: none;
            line-height: 1;
            white-space: nowrap; 
            text-align: right;
            z-index: 20;
            text-shadow: 0 0 5px black;
        }

        /* --- CENTER CONTENT SWITCHER --- */
        #slideLabel {
            background: transparent;
            border-bottom: 1px solid #333; 
            color: #ddd;
            font-size: 30px; 
            outline: none;
            padding-bottom: 2px;
            min-width: 200px;
            max-width: 60%; 
            text-align: center; 
            transition: border-color 0.2s;
            cursor: text;
            display: block; 
        }
        #slideLabel:focus { border-bottom: 1px solid #fff; }

        /* --- PDF & DRAWING CONTAINER --- */
        #pdf-render-container {
            display: none; 
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 30vh; 
            position: relative; 
            transition: height 0.1s ease; 
        }

        /* Layer 1: The PDF */
        #the-canvas {
            max-height: 100%; 
            max-width: 80%;
            border: 1px solid #333;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            position: absolute; 
            z-index: 1;
        }

        /* Layer 2: The Drawing Layer */
        #draw-canvas {
            max-height: 100%; 
            max-width: 80%;
            position: absolute; 
            z-index: 2; 
            touch-action: none; 
            pointer-events: none; 
        }
        
        #draw-canvas.active {
            pointer-events: auto; 
            border: 1px dashed rgba(255, 255, 255, 0.2); 
        }

        #no-pdf-msg {
            color: #444;
            font-style: italic;
            position: absolute;
            font-size: 14px;
            z-index: 0;
        }

        /* --- 2. THE SCROLLING NOTES AREA --- */
        #notes-container {
            flex: 1; 
            position: relative;
            overflow: hidden; 
            display: flex;
            justify-content: center; 
            border-top: 1px solid #111;
            background: #050505;
        }

        #notes-wrapper {
            width: 100%;
            max-width: 800px;
            height: 100%;
            padding: 20px;
            overflow-y: auto;
            position: relative;
        }
        
        #notes-wrapper::-webkit-scrollbar { width: 10px; }
        #notes-wrapper::-webkit-scrollbar-track { background: #111; }
        #notes-wrapper::-webkit-scrollbar-thumb { background: #333; border-radius: 5px; }

        /* The Editor (Hidden by default) */
        #slideNotesEditor {
            width: 100%;
            min-height: 100%;
            background: transparent;
            border: none;
            color: #aaa; 
            font-size: 18px; 
            text-align: left; 
            outline: none;
            font-family: 'Consolas', 'Courier New', monospace; 
            resize: none;
            line-height: 1.6;
            display: none; 
        }

        /* The Preview (Shown by default) */
        #slideNotesPreview {
            width: 100%;
            min-height: 100%;
            color: #ddd;
            font-size: 18px;
            line-height: 1.6;
            display: block;
            cursor: text; 
        }

        /* Tiny Manual Toggle Button */
        #notes-mode-toggle {
            position: absolute;
            top: 10px;
            right: 20px; 
            z-index: 100;
            background: transparent;
            border: 1px solid #333;
            color: #555;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            opacity: 0.3;
            transition: opacity 0.2s;
        }
        #notes-mode-toggle:hover { opacity: 1; color: #fff; border-color: #666; }

        /* Markdown Styling */
        #slideNotesPreview h1, #slideNotesPreview h2, #slideNotesPreview h3 { color: #fff; margin-top: 0; border-bottom: 1px solid #333; padding-bottom: 5px; }
        #slideNotesPreview code { background: #222; padding: 2px 5px; border-radius: 3px; font-family: monospace; color: #ff7b72; }
        #slideNotesPreview ul, #slideNotesPreview ol { padding-left: 25px; }
        #slideNotesPreview blockquote { border-left: 3px solid #444; margin: 0; padding-left: 15px; color: #777; font-style: italic; }
        #slideNotesPreview strong { color: #fff; }
        #slideNotesPreview a { color: #58a6ff; }
        .empty-placeholder { color: #444; font-style: italic; }
        
        /* Highlight Style */
        mark { background-color: #ffeb3b; color: black; border-radius: 2px; padding: 0 2px; }

        /* --- SETTINGS MENU --- */
        #menu-container { position: absolute; top: 10px; left: 10px; z-index: 100; }
        
        #gear-btn {
            background: transparent;
            color: #555;
            border: none;
            font-size: 24px;
            cursor: pointer;
            padding: 5px;
            transition: color 0.2s;
        }
        #gear-btn:hover { color: #fff; }

        #controls-panel {
            display: none;
            margin-top: 5px;
            background: #111;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #333;
            flex-direction: column;
            gap: 15px;
            width: 280px; 
        }
        #controls-panel.active { display: flex; }

        button.action-btn {
            padding: 8px;
            font-size: 12px;
            cursor: pointer;
            background: #000;
            color: #ddd;
            border: 1px solid #444;
            border-radius: 4px;
        }
        button.action-btn:hover { background: #222; }
        
        .toolbar {
            display: flex;
            gap: 5px;
            background: #222;
            padding: 5px;
            border-radius: 5px;
        }
        
        .tool-btn {
            flex: 1;
            padding: 5px;
            font-size: 11px;
            cursor: pointer;
            background: #111;
            color: #888;
            border: 1px solid #444;
            border-radius: 3px;
        }
        
        .tool-btn.active {
            background: #444;
            color: #fff;
            border-color: #666;
            font-weight: bold;
        }

        #export-btn { border-color: #4CAF50; color: #4CAF50; }
        #export-btn:hover { background: #1b331c; }

        /* --- SEARCH BAR STYLES --- */
        .search-group { display: flex; gap: 5px; align-items: center; }
        #search-input { flex: 1; background: #000; border: 1px solid #444; color: white; padding: 6px; font-size: 12px; border-radius: 4px; outline: none; }
        #search-input:focus { border-color: #4CAF50; }
        .search-nav-btn { background: #222; border: 1px solid #444; color: #aaa; cursor: pointer; padding: 6px 10px; border-radius: 4px; font-size: 12px; }
        .search-nav-btn:hover { background: #333; color: white; }
        #search-count { font-size: 10px; color: #666; min-width: 40px; text-align: center; }
        #clear-search-btn { background: transparent; border: none; color: #666; cursor: pointer; font-size: 14px; padding: 0 5px; }
        #clear-search-btn:hover { color: #ff4444; }

        .control-group { display: flex; flex-direction: column; gap: 5px; }
        label { font-size: 12px; color: #888; }
        input[type=range] { width: 100%; cursor: pointer; accent-color: #888; }
        input[type=file] { font-size: 12px; color: #aaa; }
        
        #mode-status { color: #aaa; font-size: 12px; font-weight: bold; }
        #clear-data-btn { color: #ff4444; border-color: #552222; }

    </style>
</head>
<body>

    <div id="menu-container">
        <button id="gear-btn" onclick="toggleMenu()">‚öô</button>
        <div id="controls-panel">
            
            <div class="control-group">
                <div id="mode-status">Mode: Standard</div>
                <button class="action-btn" onclick="cycleMode()">Switch Mode</button>
            </div>

            <div class="control-group">
                <label style="color:#4CAF50;">Search (Ctrl+F)</label>
                <div class="search-group">
                    <input type="text" id="search-input" placeholder="Find..." oninput="performSearch()">
                    <button id="clear-search-btn" title="Clear Search" onclick="clearSearch()">‚úñ</button>
                    <div id="search-count">0/0</div>
                </div>
                <div class="search-group">
                    <button class="search-nav-btn" style="flex:1" onclick="nextMatch(-1)">Prev</button>
                    <button class="search-nav-btn" style="flex:1" onclick="nextMatch(1)">Next</button>
                </div>
            </div>
            
            <div class="control-group" id="drawing-controls" style="display:none;">
                <label>Drawing Tools</label>
                <div class="toolbar">
                    <button class="tool-btn active" id="btn-pen" onclick="setTool('pen')">Pen</button>
                    <button class="tool-btn" id="btn-eraser" onclick="setTool('eraser')">Stroke Eraser</button>
                    <button class="tool-btn" style="color:#ff6666;" onclick="clearSlideDrawing()">Clear Slide</button>
                </div>
            </div>
            
            <hr style="width:100%; border:0; border-top:1px solid #333;">

            <div class="control-group">
                <label style="color:cyan;">1. Load Slides (PDF)</label>
                <input type="file" id="pdf-upload" accept=".pdf">
            </div>

            <div class="control-group">
                <label style="color:orange;">2. Import Notes (JSON)</label>
                <input type="file" id="json-upload" accept=".json">
            </div>

            <div class="control-group">
                <button id="export-btn" class="action-btn" onclick="exportNotes()">3. Save/Export Notes</button>
            </div>

            <hr style="width:100%; border:0; border-top:1px solid #333;">

            <div class="control-group">
                <label>Number Size</label>
                <input type="range" min="20" max="120" value="80" oninput="updateNumberSize(this.value)">
            </div>
            <div class="control-group">
                <label>Text Size</label>
                <input type="range" min="12" max="60" value="18" oninput="updateTextSize(this.value)">
            </div>
            <div class="control-group">
                <label>PDF Preview Size</label>
                <input type="range" min="10" max="60" value="30" oninput="updatePdfSize(this.value)" onchange="refreshPdfResolution()">
            </div>
            <button id="clear-data-btn" class="action-btn" onclick="clearAllData()">Reset All</button>
        </div>
    </div>

    <div id="sticky-header-group">
        <div id="display">0</div>
        <span id="slideLabel" contenteditable="true" role="textbox" data-placeholder="Header..."></span>
        
        <div id="pdf-render-container">
            <div id="no-pdf-msg">Load PDF in Settings (‚öô)</div>
            <canvas id="the-canvas"></canvas>
            <canvas id="draw-canvas"></canvas>
        </div>
    </div>

    <div id="notes-container">
        <button id="notes-mode-toggle" title="Toggle Edit/Preview" onclick="toggleNotesModeManual()">üëÅÔ∏è</button>
        
        <div id="notes-wrapper">
            <textarea id="slideNotesEditor" placeholder="Type Markdown notes here..."></textarea>
            <div id="slideNotesPreview" onclick="activateEditor()"></div>
        </div>
    </div>

    <script>
        // --- STATE ---
        const savedData = localStorage.getItem('slideTrackerData_Project_Search_Highlight_Enter'); 
        let state = savedData ? JSON.parse(savedData) : { count: 0, memory: {} };
        if(isNaN(state.count)) state.count = 0;
        
        const MODES = ['NUM', 'PULSE', 'PDF'];
        let currentModeIndex = 0; 
        
        let pdfDoc = null;
        let renderTask = null;

        const pdfCanvas = document.getElementById('the-canvas');
        const drawCanvas = document.getElementById('draw-canvas');
        const pdfCtx = pdfCanvas.getContext('2d');
        const drawCtx = drawCanvas.getContext('2d');
        
        const display = document.getElementById('display');
        const slideLabel = document.getElementById('slideLabel');
        
        const editor = document.getElementById('slideNotesEditor');
        const preview = document.getElementById('slideNotesPreview');
        const toggleBtn = document.getElementById('notes-mode-toggle');
        let isEditorActive = false;
        
        const pdfContainer = document.getElementById('pdf-render-container');
        const noPdfMsg = document.getElementById('no-pdf-msg');
        const modeStatus = document.getElementById('mode-status');
        const controlsPanel = document.getElementById('controls-panel');
        const drawingControls = document.getElementById('drawing-controls');
        const btnPen = document.getElementById('btn-pen');
        const btnEraser = document.getElementById('btn-eraser');
        
        // SEARCH VARS
        const searchInput = document.getElementById('search-input');
        const searchCount = document.getElementById('search-count');
        let searchMatches = []; 
        let currentMatchPos = -1;

        let timeoutHandle = null;
        let notesViewMode = 'edit'; 

        // Init
        updateUIForMode();
        updateDisplay();

        function saveData() {
            localStorage.setItem('slideTrackerData_Project_Search_Highlight_Enter', JSON.stringify(state));
        }

        // --- SEARCH LOGIC (Enter to Navigate) ---
        function performSearch() {
            const query = searchInput.value.toLowerCase().trim();
            searchMatches = [];
            
            // If empty, clear everything and refresh
            if (query.length === 0) {
                currentMatchPos = -1;
                searchCount.textContent = "0/0";
                updateDisplay(); 
                return;
            }

            handleInput(); // Save current work

            const indices = Object.keys(state.memory).map(Number).sort((a,b) => a-b);
            if(indices.length === 0) return;
            const maxIndex = indices[indices.length-1];

            for (let i = 0; i <= maxIndex; i++) {
                const data = state.memory[i];
                if (!data) continue;
                const header = (data.header || "").toLowerCase();
                const notes = (data.notes || "").toLowerCase();
                if (header.includes(query) || notes.includes(query)) {
                    searchMatches.push(i);
                }
            }

            if (searchMatches.length > 0) {
                // Find next match relative to current slide
                const upcoming = searchMatches.findIndex(idx => idx >= state.count);
                currentMatchPos = (upcoming !== -1) ? upcoming : 0;
                searchCount.textContent = `${currentMatchPos + 1}/${searchMatches.length}`;
            } else {
                currentMatchPos = -1;
                searchCount.textContent = "0/0";
            }
            // Show highlights on current page if match exists there
            updateDisplay();
        }

        function nextMatch(dir) {
            if (searchMatches.length === 0) return;
            
            // Smart Jump Logic:
            // If we are currently AT the slide indicated by match, move index.
            // If we are NOT at the slide (e.g. first Enter press), just jump there without moving index.
            if (state.count === searchMatches[currentMatchPos]) {
                currentMatchPos += dir;
            }

            // Wrap
            if (currentMatchPos >= searchMatches.length) currentMatchPos = 0;
            if (currentMatchPos < 0) currentMatchPos = searchMatches.length - 1;

            searchCount.textContent = `${currentMatchPos + 1}/${searchMatches.length}`;
            state.count = searchMatches[currentMatchPos];
            saveData();
            updateDisplay();
            
            activatePreview(); 
            if (MODES[currentModeIndex] === 'PDF' && pdfDoc) renderPage(state.count + 1);
        }

        function clearSearch() {
            searchInput.value = "";
            performSearch();
            searchInput.blur();
        }

        // --- SMART NOTES LOGIC ---
        function activateEditor() {
            isEditorActive = true;
            editor.style.display = 'block';
            preview.style.display = 'none';
            toggleBtn.textContent = '‚úèÔ∏è'; 
            editor.focus();
        }

        function activatePreview() {
            isEditorActive = false;
            editor.style.display = 'none';
            preview.style.display = 'block';
            toggleBtn.textContent = 'üëÅÔ∏è'; 
            updateDisplay(); // Force re-render with potential highlights
        }

        function toggleNotesModeManual() {
            if(isEditorActive) activatePreview();
            else activateEditor();
        }

        editor.addEventListener('blur', (e) => {
            setTimeout(() => {
                if (document.activeElement !== toggleBtn) {
                    activatePreview();
                }
            }, 100);
        });

        // Auto-bullets
        editor.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                const start = editor.selectionStart;
                const end = editor.selectionEnd;
                const text = editor.value;
                const lineStart = text.lastIndexOf('\n', start - 1) + 1;
                const currentLine = text.substring(lineStart, start);
                const match = currentLine.match(/^(\s*)([-*]|\d+\.)\s/);
                if (match) {
                    e.preventDefault();
                    const prefix = match[0];
                    const newText = text.substring(0, start) + '\n' + prefix + text.substring(end);
                    editor.value = newText;
                    editor.selectionStart = editor.selectionEnd = start + prefix.length + 1;
                    handleInput(); 
                }
            }
        });

        // --- DRAWING LOGIC ---
        let isDrawing = false; let isErasing = false; let currentTool = 'pen'; let currentStrokes = []; 
        function setTool(tool) {
            currentTool = tool;
            if(tool === 'pen') { btnPen.classList.add('active'); btnEraser.classList.remove('active'); drawCanvas.style.cursor = 'crosshair'; } 
            else { btnPen.classList.remove('active'); btnEraser.classList.add('active'); drawCanvas.style.cursor = 'cell'; }
        }
        function clearSlideDrawing() {
            if(confirm("Clear drawings for this slide?")) {
                if (state.memory[state.count]) { state.memory[state.count].drawings = []; saveData(); renderDrawings(); }
            }
        }
        function toNorm(x, y) { return { x: x / drawCanvas.width, y: y / drawCanvas.height }; }
        function toPixel(xNorm, yNorm) { return { x: xNorm * drawCanvas.width, y: yNorm * drawCanvas.height }; }
        function getNormalizedPos(e) {
            const rect = drawCanvas.getBoundingClientRect();
            return { x: (e.clientX - rect.left) / rect.width, y: (e.clientY - rect.top) / rect.height };
        }
        drawCanvas.addEventListener('mousedown', (e) => {
            const norm = getNormalizedPos(e);
            if (currentTool === 'eraser') { isErasing = true; const px = toPixel(norm.x, norm.y); eraseStrokeAtInternal(px.x, px.y); } 
            else { isDrawing = true; currentStrokes.push({ points: [norm] }); const px = toPixel(norm.x, norm.y); drawCtx.lineWidth = 3; drawCtx.strokeStyle = 'red'; drawCtx.lineCap = 'round'; drawCtx.beginPath(); drawCtx.moveTo(px.x, px.y); drawCtx.lineTo(px.x, px.y); drawCtx.stroke(); }
        });
        drawCanvas.addEventListener('mousemove', (e) => {
            const norm = getNormalizedPos(e);
            const px = toPixel(norm.x, norm.y);
            if (currentTool === 'eraser' && isErasing) { eraseStrokeAtInternal(px.x, px.y); return; }
            if (currentTool === 'pen' && isDrawing) {
                const currentPath = currentStrokes[currentStrokes.length - 1];
                const lastNorm = currentPath.points[currentPath.points.length - 1];
                const lastPx = toPixel(lastNorm.x, lastNorm.y);
                drawCtx.lineWidth = 3; drawCtx.strokeStyle = 'red'; drawCtx.lineCap = 'round'; drawCtx.beginPath(); drawCtx.moveTo(lastPx.x, lastPx.y); drawCtx.lineTo(px.x, px.y); drawCtx.stroke();
                currentPath.points.push(norm);
            }
        });
        drawCanvas.addEventListener('mouseup', endAction); drawCanvas.addEventListener('mouseout', endAction);
        function endAction() { if(isDrawing) { isDrawing = false; saveDrawingsToState(); } if(isErasing) { isErasing = false; } }
        function eraseStrokeAtInternal(internalX, internalY) {
            const data = state.memory[state.count] || {}; const drawings = data.drawings || []; if(drawings.length === 0) return;
            const eraserRadius = 25; 
            const remainingDrawings = drawings.filter(path => {
                const isTouched = path.points.some(ptNorm => { const ptPx = toPixel(ptNorm.x, ptNorm.y); const dist = Math.hypot(ptPx.x - internalX, ptPx.y - internalY); return dist < eraserRadius; });
                return !isTouched; 
            });
            if(remainingDrawings.length !== drawings.length) { state.memory[state.count].drawings = remainingDrawings; saveData(); renderDrawings(); }
        }
        function saveDrawingsToState() {
            if (!state.memory[state.count]) state.memory[state.count] = {};
            const existing = state.memory[state.count].drawings || [];
            state.memory[state.count].drawings = existing.concat(currentStrokes);
            currentStrokes = []; saveData();
        }
        function renderDrawings() {
            drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
            const data = state.memory[state.count] || {}; const drawings = data.drawings || [];
            drawings.forEach(path => {
                drawCtx.strokeStyle = 'red'; drawCtx.lineWidth = 3; drawCtx.lineCap = 'round'; drawCtx.lineJoin = 'round'; if (path.points.length < 1) return;
                drawCtx.beginPath(); const start = toPixel(path.points[0].x, path.points[0].y); drawCtx.moveTo(start.x, start.y);
                for (let i = 1; i < path.points.length; i++) { const pt = toPixel(path.points[i].x, path.points[i].y); drawCtx.lineTo(pt.x, pt.y); } drawCtx.stroke();
            });
        }
        function resizeDrawLayer() { drawCanvas.width = pdfCanvas.width; drawCanvas.height = pdfCanvas.height; renderDrawings(); }

        // --- APP LOGIC ---
        function handleInput() {
            if (!state.memory[state.count]) state.memory[state.count] = {};
            state.memory[state.count].header = slideLabel.innerText;
            state.memory[state.count].notes = editor.value; 
            saveData();
        }
        slideLabel.addEventListener('input', handleInput);
        editor.addEventListener('input', handleInput);
        slideLabel.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); slideLabel.blur(); }});

        function handleNav(direction) {
            const mode = MODES[currentModeIndex];
            if(isEditorActive) activatePreview();
            if (direction === 'forward') { state.count++; if (mode === 'PULSE') triggerFlash(">>>"); } 
            else if (direction === 'backward') { if (state.count > 0) { state.count--; if (mode === 'PULSE') triggerFlash("<<<"); } }
            saveData(); updateDisplay();
            if (mode === 'PDF' && pdfDoc) renderPage(state.count + 1);
        }

        function updateDisplay() {
            const mode = MODES[currentModeIndex];
            const data = state.memory[state.count] || {};
            if (mode !== 'PDF') slideLabel.innerText = data.header || "";
            const noteContent = data.notes || "";
            editor.value = noteContent;
            
            // --- UPDATED RENDERER WITH HIGHLIGHTING ---
            let htmlContent = "";
            if (typeof marked !== 'undefined') { 
                htmlContent = noteContent.trim() ? marked.parse(noteContent) : '<span class="empty-placeholder">Click to add notes...</span>'; 
            } else { 
                htmlContent = noteContent; 
            }

            const searchTerm = searchInput.value.trim();
            if (searchTerm.length > 0) {
                const regex = new RegExp(`(${searchTerm})`, 'gi');
                htmlContent = htmlContent.replace(regex, '<mark>$1</mark>');
            }
            preview.innerHTML = htmlContent;

            if (mode === 'NUM' || mode === 'PDF') { display.textContent = state.count; display.style.color = "white"; } 
            else if (mode === 'PULSE') { if (!timeoutHandle) { display.textContent = "---"; display.style.color = "#333"; } }
        }

        function triggerFlash(symbol) {
            if (timeoutHandle) clearTimeout(timeoutHandle);
            display.textContent = symbol; display.style.color = "white"; 
            timeoutHandle = setTimeout(() => { display.textContent = "---"; display.style.color = "#333"; timeoutHandle = null; }, 500);
        }

        function cycleMode() {
            currentModeIndex = (currentModeIndex + 1) % MODES.length;
            updateUIForMode();
            if (MODES[currentModeIndex] === 'PDF' && pdfDoc) renderPage(state.count + 1);
        }

        function updateUIForMode() {
            const mode = MODES[currentModeIndex];
            if (mode === 'PDF') {
                slideLabel.style.display = 'none'; pdfContainer.style.display = 'flex'; modeStatus.textContent = "Mode: PDF Slides";
                drawCanvas.classList.add('active'); drawingControls.style.display = 'flex'; setTool('pen'); 
            } else {
                slideLabel.style.display = 'block'; pdfContainer.style.display = 'none'; modeStatus.textContent = (mode === 'NUM') ? "Mode: Standard" : "Mode: No Numbers";
                drawCanvas.classList.remove('active'); drawingControls.style.display = 'none';
            }
            if(timeoutHandle) { clearTimeout(timeoutHandle); timeoutHandle = null; }
            updateDisplay(); 
        }

        // --- PDF ENGINE ---
        document.getElementById('pdf-upload').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file && file.type === "application/pdf") {
                const fileReader = new FileReader();
                fileReader.onload = function() {
                    const typedarray = new Uint8Array(this.result);
                    pdfjsLib.getDocument(typedarray).promise.then(function(pdfDoc_) {
                        pdfDoc = pdfDoc_; noPdfMsg.style.display = "none";
                        if (MODES[currentModeIndex] === 'PDF') renderPage(state.count + 1);
                    });
                };
                fileReader.readAsArrayBuffer(file);
            }
        });

        function renderPage(num) {
            if (renderTask) renderTask.cancel();
            if (!pdfDoc || num < 1 || num > pdfDoc.numPages) return;
            pdfDoc.getPage(num).then(function(page) {
                const containerHeight = pdfContainer.clientHeight;
                const unscaledViewport = page.getViewport({scale: 1});
                const scale = containerHeight / unscaledViewport.height;
                const viewport = page.getViewport({scale: scale});
                pdfCanvas.height = viewport.height; pdfCanvas.width = viewport.width;
                resizeDrawLayer();
                const renderContext = { canvasContext: pdfCtx, viewport: viewport };
                renderTask = page.render(renderContext);
                renderTask.promise.then(() => { renderTask = null; }).catch((err) => { if(err.name !== 'RenderingCancelledException') console.log(err); });
            });
        }

        // --- JSON EXPORT ---
        function exportNotes() {
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(state));
            const downloadAnchorNode = document.createElement('a'); downloadAnchorNode.setAttribute("href", dataStr);
            const date = new Date().toISOString().slice(0,10); downloadAnchorNode.setAttribute("download", "lecture_notes_" + date + ".json");
            document.body.appendChild(downloadAnchorNode); downloadAnchorNode.click(); downloadAnchorNode.remove();
        }
        document.getElementById('json-upload').addEventListener('change', function(e) {
            const file = e.target.files[0]; if (!file) return;
            const reader = new FileReader();
            reader.onload = function(event) {
                try {
                    state = JSON.parse(event.target.result);
                    if(isNaN(state.count)) state.count = 0;
                    saveData(); updateDisplay();
                    if(pdfDoc && MODES[currentModeIndex] === 'PDF') renderPage(state.count + 1);
                    alert("Notes & Drawings loaded!");
                } catch(err) { alert("Error reading JSON"); }
            };
            reader.readAsText(file);
        });

        // --- UTILS ---
        function toggleMenu() { controlsPanel.classList.toggle('active'); 
            if(controlsPanel.classList.contains('active')) setTimeout(() => searchInput.focus(), 100);
        }
        function updateNumberSize(val) { display.style.fontSize = val + "px"; }
        function updateTextSize(val) { editor.style.fontSize = val + "px"; preview.style.fontSize = val + "px"; slideLabel.style.fontSize = (val * 1.5) + "px"; }
        function updatePdfSize(val) { pdfContainer.style.height = val + "vh"; }
        function refreshPdfResolution() { if (MODES[currentModeIndex] === 'PDF' && pdfDoc) renderPage(state.count + 1); }
        function clearAllData() {
            if(confirm("Reset all?")) { state = { count: 0, memory: {} }; saveData(); updateDisplay(); if(pdfDoc) renderPage(1); }
        }

        // --- SEARCH INPUT LISTENER (For Enter Navigation) ---
        searchInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                if(e.shiftKey) nextMatch(-1);
                else nextMatch(1);
            }
        });

        document.addEventListener('keydown', e => {
            if (e.key === 'Escape') { 
                clearSearch(); // Clear search on Esc
                activatePreview(); 
                if(controlsPanel.classList.contains('active')) toggleMenu(); 
                document.activeElement.blur(); 
                return; 
            }
            if ((e.ctrlKey || e.metaKey) && e.key === 'f') { 
                e.preventDefault(); 
                if(!controlsPanel.classList.contains('active')) toggleMenu(); 
                searchInput.focus(); 
                return; 
            }
            if (e.ctrlKey || e.metaKey) {
                if (e.key === 'ArrowUp' || e.key === 'ArrowRight') { e.preventDefault(); handleNav('forward'); return; }
                if (e.key === 'ArrowDown' || e.key === 'ArrowLeft') { e.preventDefault(); handleNav('backward'); return; }
            }
            if (document.activeElement === editor || document.activeElement === searchInput) return;
            if (document.activeElement === slideLabel) {
                 if (['ArrowUp','ArrowDown'].includes(e.key)) { e.preventDefault(); handleNav(e.key === 'ArrowUp' ? 'forward' : 'backward'); } return;
            }
            if(e.key === 'ArrowUp' || e.key === 'ArrowRight') handleNav('forward');
            else if(e.key === 'ArrowDown' || e.key === 'ArrowLeft') handleNav('backward');
        });
    </script>
</body>
</html>